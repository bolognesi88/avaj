package Parser;

import java.util.*;
import java_cup.runtime.*;

/* a good source of java grammars https://github.com/antlr/grammars-v4/tree/master/java */


/* Terminals (tokens returned by the scanner) */
/* declarations */		
terminal	PACKAGE	;
terminal	IMPORT	;
terminal	CLASS	;
terminal	ENUM	;
terminal	INTERFACE	;
terminal	EXTENDS	;
terminal	IMPLEMENTS	;
terminal	INSTANCEOF;
		
		
/* types */		
terminal	BYTE	;
terminal	SHORT	;
terminal	CHAR	;
terminal	INT	;
terminal	LONG	;
terminal	FLOAT	;
terminal	DOUBLE	;
terminal	BOOLEAN	;
		
		
terminal	VOID	;
terminal	THIS	;
terminal	SUPER	;
terminal	NEW	;
terminal	TRUE	;
terminal	FALSE	;
terminal	NULL	;
		
		
/* control flow */		
terminal	IF	;
terminal	ELSE	;
terminal	FOR	;
terminal	WHILE	;
terminal	RETURN	;
terminal	DO	;
terminal	ASSERT	;
terminal	SWITCH	;
terminal	CASE	;
terminal	DEFAULT	;
terminal	BREAK	;
terminal	CONTINUE	;
terminal	TRY	;
terminal	CATCH	;
terminal	FINALLY	;
terminal	THROW	;
terminal	THROWS	;
		
		
/* modifiers */		
terminal	PUBLIC	;
terminal	PROTECTED	;
terminal	PRIVATE	;
terminal	STATIC	;
terminal	ABSTRACT	;
terminal	FINAL	;
terminal	NATIVE	;
terminal	SYNCHRONIZED	;
terminal	TRANSIENT	;
terminal	VOLATILE	;
terminal	STRICTFP	;
		
		
/* literals */		
terminal	INTEGER_LITERAL	;
terminal    STRING_LITERAL;
terminal 	CHARACTER_LITERAL;
terminal	FLOATING_POINT_LITERAL;
		
/* operators */		
terminal	GE	;
terminal	LE	;
terminal	EQUALS	;
terminal	NOT_EQUALS	;
terminal	DOUBLE_OR	;
terminal	DOUBLE_AND	;
terminal	SHIFT_LEFT	;
terminal	SHIFT_RIGHT	;
terminal	SHIFT_RIGHT_ARITHM	;
terminal	INC	;
terminal	DEC	;
		
		
terminal	PLUS	;
terminal	MINUS	;
terminal	TIMES	;
terminal	DIVIDE	;
terminal	NOT	;
terminal	AND	;
terminal	OR	;
terminal	XOR	;
terminal	MOD	;
terminal	BITWISE_NOT	;		
terminal	HASH	;
terminal	BACKSLASH	;
		
/* assignments */		
terminal	PLUS_EQUALS	;
terminal	MINUS_EQUALS	;
terminal	TIMES_EQUALS	;
terminal	DIV_EQUALS	;
terminal	AND_EQUALS	;
terminal	OR_EQUALS	;
terminal	XOR_EQUALS	;
terminal	MOD_EQUALS	;
terminal	SHIFT_LEFT_EQUALS	;
terminal	SHIFT_RIGHT_EQUALS	;
terminal	SHIFT_RIGHT_ARITHM_EQUALS	;
terminal	BECOMES	;
		
    		
/* delimiters */		
terminal	LPAREN	;
terminal	RPAREN	;
terminal	LBRACKET	;
terminal	RBRACKET	;
terminal	LBRACE	;
terminal	RBRACE	;
terminal	LT	;
terminal	GT	;
		
		
/* punctuation */		
terminal    ELLIPSIS;
terminal	DOT	;
terminal	COMMA	;
terminal	SEMICOLON	;
terminal	COLON	;
terminal	QUESTION	;
terminal    AT ; 

/* identifiers */		
terminal	IDENTIFIER	;



/* novelties */
terminal    ARROW;
terminal    DOUBLE_COLON;



/* Nonterminals */
nonterminal	Goal	;
nonterminal	Literal	;
nonterminal	IntegerLiteral	;
nonterminal	FloatingPointLiteral	;
nonterminal	BooleanLiteral	;
nonterminal	CharacterLiteral	;
nonterminal	StringLiteral	;
nonterminal	NullLiteral	;
nonterminal	Type	;
nonterminal	PrimitiveType	;
nonterminal	NumericType	;
nonterminal	IntegralType	;
nonterminal	FloatingPointType	;
nonterminal	ReferenceType	;
nonterminal	ClassOrInterfaceType	;
nonterminal	ClassType	;
nonterminal	InterfaceType	;
nonterminal	ArrayType	;
nonterminal	Name	;
nonterminal	SimpleName	;
nonterminal	QualifiedName	;
nonterminal	CompilationUnit	;
nonterminal	PackageDeclaration_opt	;
nonterminal	ImportDeclarations_opt	;
nonterminal	TypeDeclarations_opt	;
nonterminal	ImportDeclarations	;
nonterminal	TypeDeclarations	;
nonterminal	PackageDeclaration	;
nonterminal	ImportDeclaration	;
nonterminal	SingleTypeImportDeclaration	;
nonterminal	TypeImportOnDemandDeclaration	;
nonterminal	TypeDeclaration	;
nonterminal	Modifiers	;
nonterminal	Modifier	;
nonterminal	ClassDeclaration	;
nonterminal	Modifiers_opt	;
nonterminal	Super_opt	;
nonterminal	Interfaces_opt	;
nonterminal	Super	;
nonterminal	Interfaces	;
nonterminal	InterfaceTypeList	;
nonterminal	ClassBody	;
nonterminal	ClassBodyDeclarations_opt	;
nonterminal	ClassBodyDeclarations	;
nonterminal	ClassBodyDeclaration	;
nonterminal	ClassMemberDeclaration	;
nonterminal	FieldDeclaration	;
nonterminal	VariableDeclarators	;
nonterminal	VariableDeclarator	;
nonterminal	VariableDeclaratorId	;
nonterminal	VariableInitializer	;
nonterminal	MethodDeclaration	;
nonterminal	MethodHeader	;
nonterminal	Throws_opt	;
nonterminal	MethodDeclarator	;
nonterminal	FormalParameterList_opt	;
nonterminal	FormalParameterList	;
nonterminal	FormalParameter	;
nonterminal	Throws	;
nonterminal	ClassTypeList	;
nonterminal	MethodBody	;
nonterminal	StaticInitializer	;
nonterminal	ConstructorDeclaration	;
nonterminal	ConstructorDeclarator	;
nonterminal	ConstructorBody	;
nonterminal	BlockStatements_opt	;
nonterminal	ExplicitConstructorInvocation	;
nonterminal	InterfaceDeclaration	;
nonterminal	ExtendsInterfaces_opt	;
nonterminal	ExtendsInterfaces	;
nonterminal	InterfaceBody	;
nonterminal	InterfaceMemberDeclarations_opt	;
nonterminal	InterfaceMemberDeclarations	;
nonterminal	InterfaceMemberDeclaration	;
nonterminal	ConstantDeclaration	;
nonterminal	AbstractMethodDeclaration	;
nonterminal	ArrayInitializer	;
nonterminal	Comma_opt	;
nonterminal	VariableInitializers	;
nonterminal	Block	;
nonterminal	BlockStatements	;
nonterminal	BlockStatement	;
nonterminal	LocalVariableDeclarationStatement	;
nonterminal	LocalVariableDeclaration	;
nonterminal	Statement	;
nonterminal	StatementNoShortIf	;
nonterminal	StatementWithoutTrailingSubstatement	;
nonterminal	EmptyStatement	;
nonterminal	LabeledStatement	;
nonterminal	LabeledStatementNoShortIf	;
nonterminal	ExpressionStatement	;
nonterminal	StatementExpression	;
nonterminal	IfThenStatement	;
nonterminal	IfThenElseStatement	;
nonterminal	IfThenElseStatementNoShortIf	;
nonterminal	SwitchStatement	;
nonterminal	SwitchBlock	;
nonterminal	SwitchBlockStatementGroups	;
nonterminal	SwitchBlockStatementGroup	;
nonterminal	SwitchLabels	;
nonterminal	SwitchLabel	;
nonterminal	WhileStatement	;
nonterminal	WhileStatementNoShortIf	;
nonterminal	DoStatement	;
nonterminal	ForStatement	;
nonterminal	ForStatementNoShortIf	;
nonterminal	ForInit_opt	;
nonterminal	Expression_opt	;
nonterminal	ForUpdate_opt	;
nonterminal	ForInit	;
nonterminal	ForUpdate	;
nonterminal	StatementExpressionList	;
nonterminal	BreakStatement	;
nonterminal Identifier_opt	;
nonterminal	ContinueStatement	;
nonterminal	ReturnStatement	;
nonterminal	ThrowStatement	;
nonterminal	SynchronizedStatement	;
nonterminal	TryStatement	;
nonterminal	Catches_opt	;
nonterminal	Catches	;
nonterminal	CatchClause	;
nonterminal	Finally	;
nonterminal	Primary	;
nonterminal	PrimaryNoNewArray	;
nonterminal	ClassInstanceCreationExpression	;
nonterminal	ArgumentList_opt	;
nonterminal	ArgumentList	;
nonterminal	ArrayCreationExpression	;
nonterminal	Dims_opt	;
nonterminal	DimExprs	;
nonterminal	DimExpr	;
nonterminal	Dims	;
nonterminal	FieldAccess	;
nonterminal	MethodInvocation	;
nonterminal	ArrayAccess	;
nonterminal	PostfixExpression	;
nonterminal	PostIncrementExpression	;
nonterminal	PostDecrementExpression	;
nonterminal	UnaryExpression	;
nonterminal	PreIncrementExpression	;
nonterminal	PreDecrementExpression	;
nonterminal	UnaryExpressionNotPlusMinus	;
nonterminal	CastExpression	;
nonterminal	MultiplicativeExpression	;
nonterminal	AdditiveExpression	;
nonterminal	ShiftExpression	;
nonterminal	RelationalExpression	;
nonterminal	EqualityExpression	;
nonterminal	AndExpression	;
nonterminal	ExclusiveOrExpression	;
nonterminal	InclusiveOrExpression	;
nonterminal	ConditionalAndExpression	;
nonterminal	ConditionalOrExpression	;
nonterminal	ConditionalExpression	;
nonterminal	AssignmentExpression	;
nonterminal	Assignment	;
nonterminal	LeftHandSide	;
nonterminal	AssignmentOperator	;
nonterminal	Expression	;
nonterminal	ConstantExpression	;

/* little aditions to old structures */
nonterminal Identifier;
nonterminal AssertStatement;
nonterminal ForVarControl;
nonterminal DefaultMethodDeclararation;
nonterminal TryResources;
nonterminal Resource;
nonterminal CatchTypes;
nonterminal VariableModifiers;
nonterminal ClassLiteral;

/* new structures */

nonterminal Annotation;
nonterminal AnnotationElement;
nonterminal ElementValuePairs;
nonterminal ElementValuePair;
nonterminal ElementValue;
nonterminal ElementValueArrayInitializer; 
nonterminal ElementValues;



nonterminal EnumDeclaration;
nonterminal EnumBody;
nonterminal EnumConstants;
nonterminal EnumConstant;
nonterminal Annotations_opt;
nonterminal EnumBodyDeclarations;



nonterminal AnnotationTypeDeclaration; 
nonterminal AnnotationTypeBody;
nonterminal AnnotationTypeElementDeclarations;
nonterminal AnnotationTypeElementDeclaration;
nonterminal AnnotationTypeElementRest;
nonterminal AnnotationMethodOrConstantRest;
nonterminal AnnotationMethodRest;
nonterminal ConstantDeclaratorRest;




nonterminal LambdaExpression;
nonterminal LambdaParameters;
nonterminal IdentifierList;	
nonterminal LambdaBody;
nonterminal VariableModifier;






nonterminal TypeArgumentsOrDiamond;
nonterminal TypeArguments;
nonterminal TypeArgumentList;
nonterminal TypeArgument;
nonterminal Wildcard;
nonterminal WildcardBounds;







/* Precedence declarations */
/* The last precedence declaration give its terminals the highest precedence */
/* https://introcs.cs.princeton.edu/java/11precedence/ */

/* precedence right lambda -> */
precedence right ARROW;
precedence right BECOMES, PLUS_EQUALS, MINUS_EQUALS, TIMES_EQUALS, DIV_EQUALS, MOD_EQUALS, AND_EQUALS, XOR_EQUALS, OR_EQUALS, SHIFT_LEFT_EQUALS, SHIFT_RIGHT_EQUALS, SHIFT_RIGHT_ARITHM_EQUALS; /* level 1*/
precedence left QUESTION, COLON; 		/* level 2*/
precedence left DOUBLE_OR; 				/* level 3*/
precedence left DOUBLE_AND; 			/* level 4*/
precedence left OR; 					/* level 5*/
precedence left XOR; 					/* level 6*/
precedence left AND; 					/* level 7*/
precedence left EQUALS, NOT_EQUALS; 	/* LEVEL 8 */
precedence left LT, GT, LE, GE, INSTANCEOF;   					/* LEVEL 9 */
precedence left SHIFT_LEFT, SHIFT_RIGHT, SHIFT_RIGHT_ARITHM;   	/* LEVEL 10 */
precedence left PLUS, MINUS; 			/* LEVEL 11 */
precedence left TIMES, DIVIDE, MOD; 	/* LEVEL 12 */
precedence right NOT, BITWISE_NOT;		/* LEVEL 14 + UNARY PLUS MINUS PREINC, PREDEC */
precedence nonassoc AT, ELSE;					/* ? */
precedence left INC, DEC; 				/* LEVEL 15*/
precedence left LPAREN, RPAREN, LBRACE, RBRACE, NEW, DOT; 		/*LEVEL 16, + METHOD REFERENCE :: */



start with Goal;



/* Productions */
/* 19.2 Productions from ยง2.3: The Syntactic Grammar */

Goal::=
    	CompilationUnit:i  		{: RESULT = i; :}
    	;

CompilationUnit::=
    	TypeDeclarations_opt:t	{: RESULT = t; :}
    	;








TypeDeclarations_opt::= TypeDeclarations_opt:o Modifiers:m TypeDeclaration:t		{: RESULT = o+"\n"+m+" "+t; :}
		|
		TypeDeclarations_opt:o TypeDeclaration:t		{: RESULT = o+"\n"+t; :}
		| 
		{: RESULT = ""; :}
    	;
TypeDeclaration::=
    	CLASS ClassDeclaration:i					{: RESULT = i; :}
    	|
    	INTERFACE InterfaceDeclaration:i			{: RESULT = i; :}
    	|
		ENUM EnumDeclaration:i						{: RESULT = i; :}
		|
		AT INTERFACE AnnotationTypeDeclaration:i	{: RESULT = i; :}
    	;
ClassDeclaration::=
    	IDENTIFIER:i Super_opt:s Interfaces_opt:r ClassBody:b {: RESULT = "class "+i+s+r+" "+b; :}
    	;
InterfaceDeclaration::=
    	IDENTIFIER:i ExtendsInterfaces_opt:r InterfaceBody:b {: RESULT = "interface "+i+r+" "+b; :}
    	;
EnumDeclaration::=
    	IDENTIFIER:i Interfaces_opt:r EnumBody:b  {: RESULT = "enum "+i+r+" "+b; :}
    	;
AnnotationTypeDeclaration::=
    	IDENTIFIER:i AnnotationTypeBody:b {: RESULT = "@interface "+i+" "+b; :}
    	;
Super_opt::= EXTENDS Name:n 		{: RESULT = " extends "+n; :}
		|
		{: RESULT = ""; :}
		;
Interfaces_opt::= IMPLEMENTS InterfaceTypeList:i	{: RESULT = " implements "+i; :}
		|
		{: RESULT = ""; :}
		;
ExtendsInterfaces_opt::= EXTENDS InterfaceTypeList:i	{: RESULT = " extends "+i; :}
		|
		{: RESULT = ""; :}
		;
InterfaceTypeList::=
    	InterfaceTypeList:i COMMA Type:n		{: RESULT = i+", "+n; :}
    	|
    	Type:n									{: RESULT = n; :}
    	;
Modifiers::=
		Modifiers:m Modifier:n 			{: RESULT = m+" "+n; :}
	    |
	    Modifier:n 						{: RESULT = n; :}
	    ;
Modifier::=	    
		AT Name:i LPAREN AnnotationElement:p RPAREN						{: RESULT = "@"+i+"("+p+")"; :}
		|
		AT Name:i LPAREN RPAREN						{: RESULT = "@"+i+"()"; :}
		|
		AT Name:i		{: RESULT = "@"+i; :}										
		| FINAL:i 			{: RESULT = i ; :}
	    | PUBLIC:i 			{: RESULT = i ; :}
	    | PROTECTED:i 		{: RESULT = i ; :}
	    | PRIVATE:i 		{: RESULT = i ; :}
	    | STATIC:i 			{: RESULT = i ; :}
	    | ABSTRACT:i 		{: RESULT = i ; :}	    
	    | NATIVE:i 			{: RESULT = i ; :}
	    | SYNCHRONIZED:i 	{: RESULT = i ; :}
	    | TRANSIENT:i 		{: RESULT = i ; :}
	    | VOLATILE:i 		{: RESULT = i ; :}
	    | STRICTFP:i 		{: RESULT = i ; :}	    
		;	    
Name::= Name:n DOT IDENTIFIER:i 		{: RESULT = n+"."+i; :}    	
    	|    	
    	Name:p DOT CLASS				{: RESULT = p+".class"; :}
    	|
    	VOID DOT CLASS					{: RESULT = "void.class"; :}
    	|
    	IDENTIFIER:i					{: RESULT = i; :}
    	;
		


ClassBody::=
    	LBRACE ClassBodyDeclarations_opt:o RBRACE		{: RESULT = "{ "+o+" }"; :}
    	;
InterfaceBody::=
    	LBRACE InterfaceMemberDeclarations_opt:o RBRACE		{: RESULT = "{ "+o+" }"; :}
    	;
EnumBody::=
    	LBRACE EnumBodyDeclarations:i RBRACE		{: RESULT = "{ "+i+" }"; :}
    	;
AnnotationTypeBody::=
    	LBRACE AnnotationTypeElementDeclarations:i RBRACE		{: RESULT = "{ "+i+" }"; :}
    	|
    	LBRACE RBRACE		{: RESULT = "{ }"; :}
    	;
    	
    	
ClassBodyDeclarations_opt::=	
		ClassBodyDeclarations_opt:o Modifiers:m ClassBodyDeclaration:i {: RESULT = o+" "+m+" "+i; :}
		|
		ClassBodyDeclarations_opt:o ClassBodyDeclaration:i {: RESULT = o+" "+i; :}
		|
		{: RESULT = ""; :}
		;
ClassBodyDeclaration::=
    	CLASS ClassDeclaration:i					{: RESULT = i; :}
    	|
    	INTERFACE InterfaceDeclaration:i			{: RESULT = i; :}
    	|
		ENUM EnumDeclaration:i						{: RESULT = i; :}
		|
		AT INTERFACE AnnotationTypeDeclaration:i	{: RESULT = i; :}
		|
		Block:i										{: RESULT = i; :}
		|
		Type:t IDENTIFIER:i LPAREN FormalParameterList_opt:p RPAREN Throws_opt:e MethodBody:b {: RESULT = t+" "+i+"("+p+") "+e+" "+b; :}
		|
		Type:t IDENTIFIER:i BECOMES Expression:e SEMICOLON {: RESULT = t+" "+i+" = "+e+";"; :}
		|
		Type:t IDENTIFIER:i SEMICOLON {: RESULT = t+" "+i+";"; :}
		|
		IDENTIFIER:i LPAREN FormalParameterList_opt:p RPAREN Throws_opt:e MethodBody:b {: RESULT = i+"("+p+") "+e+" "+b; :}
		|
		SEMICOLON {: RESULT = ";"; :}
		;
		
		
    	
Type::=
    	BOOLEAN:i 	{: RESULT = i; :}
    	|
	    BYTE:i 		{: RESULT = i; :}
	    |
	    SHORT:i 	{: RESULT = i; :}    
	    |
	    INT:i 		{: RESULT = i; :}
	    |
	    LONG:i 		{: RESULT = i; :}
	    |
	    CHAR:i 		{: RESULT = i; :}
		|
	    FLOAT:i 	{: RESULT = i; :}
    	|
    	DOUBLE:i 	{: RESULT = i; :}
    	|
    	VOID:i 		{: RESULT = i; :}
    	|
    	Name:i 		{: RESULT = i; :}
    	|
    	Type:i Dims:d {: RESULT = i+""+d; :}
    	|
    	Type:i LT GT {: RESULT = i+"<>"; :}
    	|
    	Type:i LT InterfaceTypeList:j GT {: RESULT = i+"<"+j+">"; :}
    	;    	
ArrayAccess::=
    	Name DimExpr
		|
    	PrimaryNoNewArray DimExpr
    	;
    	
    	
FormalParameterList_opt::=	FormalParameterList_opt:o COMMA FormalParameter:p {: RESULT = o+", "+p; :}
		|
		FormalParameter:p		{: RESULT = p; :}
		|    	
		{: RESULT = ""; :}
    	;
FormalParameter::=
    	Modifiers:m Type:t IDENTIFIER:i				{: RESULT = m+""+t+" "+i; :}
    	|
    	Modifiers:m Type:t ELLIPSIS IDENTIFIER:i	{: RESULT = m+""+t+"..."+i; :}
    	|
    	Type:t IDENTIFIER:i				{: RESULT = t+" "+i; :}
    	|
    	Type:t ELLIPSIS IDENTIFIER:i	{: RESULT = t+"..."+i; :}
    	;
Throws_opt::=
    	THROWS InterfaceTypeList:j				{: RESULT = "throws "+j; :}
    	|
    	{: RESULT = ""; :}
    	;
MethodBody::=
    	Block:b   {: RESULT = b ; :}
		|
    	SEMICOLON {: RESULT = ";"; :}
    	;
    	
    	
    	
    	
    	
    	
InterfaceMemberDeclarations_opt::=	
		InterfaceMemberDeclarations_opt:o Modifiers:m ClassBodyDeclaration:i {: RESULT = o+" "+m+" "+i; :}
		|
		InterfaceMemberDeclarations_opt:o DEFAULT ClassBodyDeclaration:i {: RESULT = o+" default "+i; :}
		|
		InterfaceMemberDeclarations_opt:o ClassBodyDeclaration:i {: RESULT = o+" "+i; :}
		|
		{: RESULT = ""; :}
		;
		    	
    	
    	
    	
    	
/** Annotations **/ 
AnnotationElement::=
		    ElementValuePairs:i		{: RESULT = i; :}
		    |
		    ElementValue:i			{: RESULT = i; :}
		    ;
ElementValuePairs::= ElementValuePair:i 					{: RESULT = i; :}
			|
			ElementValuePairs:p COMMA ElementValuePair:i	{: RESULT = p+", "+i; :}
			;
ElementValuePair::= IDENTIFIER:i BECOMES ElementValue:p		{: RESULT = i+"="+p; :}
			;
ElementValue::=  Annotation:i					{: RESULT = i; :}
			|
		    Expression:i						{: RESULT = i; :}
		    |
		    ElementValueArrayInitializer:i		{: RESULT = i; :}
		    ;
ElementValueArrayInitializer::= 
			LBRACE ElementValues:i COMMA RBRACE		{: RESULT = "{"+i+",}"; :}
			|
			LBRACE ElementValues:i RBRACE			{: RESULT = "{"+i+"}"; :}
			|
			LBRACE COMMA RBRACE						{: RESULT = "{,}"; :}
			|
			LBRACE RBRACE							{: RESULT = "{}"; :}
			;
ElementValues ::= ElementValue:i						{: RESULT = i; :}
			|
			ElementValues:p COMMA	ElementValue:i		{: RESULT = p+", "+i; :}
			;
				    	
    	
    	
    	
    	
EnumBodyDeclarations::=
    EnumConstants:c COMMA			{: RESULT = c+", "; :}
    | 
    EnumConstants:c SEMICOLON ClassBodyDeclarations_opt:o		{: RESULT = c+"; "+o; :}    
    |
    {: RESULT = ""; :}
    ;
EnumConstants::=
    EnumConstants:c COMMA Annotations_opt:o IDENTIFIER:i EnumConstant:e			{: RESULT = c+", "+o+" "+i+" "+e; :}
    |
    Annotations_opt:o IDENTIFIER:i EnumConstant:e	 							{: RESULT = o+" "+i+" "+e; :}
    ;
EnumConstant::=
    LPAREN ArgumentList:p RPAREN ClassBody:b	{: RESULT = "("+p+") "+b; :}
    |
    LPAREN ArgumentList:p RPAREN				{: RESULT = "("+p+")"; :}
    |
    ClassBody:b											{: RESULT = b; :}
    |
    {: RESULT = ""; :}	
    ;
Annotations_opt::=
	Annotations_opt:o Annotation:i		{: RESULT = o+" "+i; :}
	|
	{: RESULT = ""; :}
	;
Annotation::=
		AT Name:i LPAREN AnnotationElement:p RPAREN			{: RESULT = "@"+i+"("+p+")"; :}
		|
		AT Name:i LPAREN RPAREN								{: RESULT = "@"+i+"()"; :}
		|
		AT Name:i											{: RESULT = "@"+i; :}
		;	
ArgumentList::=
    	Expression:b   {: RESULT = b ; :} 
		|
    	ArgumentList:a COMMA Expression:b   {: RESULT = a+", "+b ; :} 
    	;	    	
    	
    	
    	
    	
    	
AnnotationTypeElementDeclarations::=
	AnnotationTypeElementDeclarations:o Modifiers:m AnnotationTypeElementDeclaration:a		{: RESULT = o+" "+m+" "+a; :}
	|
	AnnotationTypeElementDeclarations:o AnnotationTypeElementDeclaration:a					{: RESULT = o+" "+a; :}
	|
    Modifiers:m AnnotationTypeElementDeclaration:a 											{: RESULT = m+" "+a; :}
    |
    AnnotationTypeElementDeclaration:a														{: RESULT = a; :}    
    ;
AnnotationTypeElementDeclaration::=
		CLASS ClassDeclaration:i					{: RESULT = i; :}
    	|
    	INTERFACE InterfaceDeclaration:i			{: RESULT = i; :}
    	|
		ENUM EnumDeclaration:i						{: RESULT = i; :}
		|
		AT INTERFACE AnnotationTypeDeclaration:i	{: RESULT = i; :}
		|
		Type:t IDENTIFIER:i AnnotationMethodOrConstantRest:e SEMICOLON {: RESULT = t+" "+i+" "+e+"; "; :}
	    ;
AnnotationMethodOrConstantRest::=
    LPAREN RPAREN LBRACKET RBRACKET DEFAULT ElementValue:e		{: RESULT = "() [] default "+e; :}
    |
    LPAREN RPAREN DEFAULT ElementValue:e						{: RESULT = "() default "+e; :}
    |
    LPAREN RPAREN LBRACKET RBRACKET								{: RESULT = "() []"; :}
    |
    LPAREN RPAREN 												{: RESULT = "()"; :}
	|
    LBRACKET RBRACKET BECOMES VariableInitializer:i				{: RESULT = "[] = "+i; :}
    |
    BECOMES VariableInitializer:i								{: RESULT = " = "+i; :}
    ;
VariableInitializer::=
    	Expression:e			{: RESULT = e; :}
		|
    	ArrayInitializer:a		{: RESULT = a; :}
    	;
VariableInitializers::=
		VariableInitializers:s COMMA VariableInitializer:i		{: RESULT = s+", "+i; :}
		|
    	VariableInitializer:i									{: RESULT = i; :}
		;
ArrayInitializer::=
    	LBRACE VariableInitializers:i COMMA RBRACE		{: RESULT = "["+i+", ]"; :}
    	|
    	LBRACE VariableInitializers:i RBRACE			{: RESULT = "["+i+"]"; :}
    	|
    	LBRACE COMMA RBRACE 							{: RESULT = "[, ]"; :}
    	|    	
    	LBRACE RBRACE									{: RESULT = "[]"; :}
    	;
    	
    	
    	
  /* ********************** BLOCK & derivatives ********************************* */  	
    	
Block::=
    	LBRACE BlockStatements_opt RBRACE	{: RESULT = "Block-1"; :}	
    	;
    	
    	
BlockStatements_opt::=	/* empty */ 	{: RESULT = "BlockStatements_opt-1 (empty)"; :}	
		|
		BlockStatements					{: RESULT = "BlockStatements_opt-2"; :}	
		;    	

BlockStatements::=
    	BlockStatement					{: RESULT = "BlockStatements-1"; :}	
		|
    	BlockStatements BlockStatement	{: RESULT = "BlockStatements-2"; :}
    	;

BlockStatement::=
    	LocalVariableDeclarationStatement	{: RESULT = "BlockStatement-1"; :}
		|
    	Statement							{: RESULT = "BlockStatement-2"; :}
    	;

LocalVariableDeclarationStatement::=	
    	LocalVariableDeclaration SEMICOLON	{: RESULT = "LocalVariableDeclarationStatement-1"; :}
    	;

LocalVariableDeclaration::=
    	Type VariableDeclarators			{: RESULT = "LocalVariableDeclaration-1"; :}
    	|
    	VariableModifiers Type VariableDeclarators			{: RESULT = "LocalVariableDeclaration-1"; :}
    	;

Statement::=
    	StatementWithoutTrailingSubstatement	{: RESULT = "Statement-1"; :}
		|
    	LabeledStatement						{: RESULT = "Statement-2"; :}
		|
    	IfThenStatement							{: RESULT = "Statement-3"; :}
		|
    	IfThenElseStatement						{: RESULT = "Statement-4"; :}
		|
    	WhileStatement							{: RESULT = "Statement-5"; :}
		|
    	ForStatement							{: RESULT = "Statement-6"; :}
    	|
    	AssertStatement							{: RESULT = "Statement-7"; :}
    	;
    	
AssertStatement::=    	
    	ASSERT Expression COLON Expression SEMICOLON	 {: RESULT = "AssertStatement-1"; :}
    	|
    	ASSERT Expression SEMICOLON  	 {: RESULT = "AssertStatement-2"; :}
    	;

StatementNoShortIf::=
    	StatementWithoutTrailingSubstatement
		|
    	LabeledStatementNoShortIf
		|
    	IfThenElseStatementNoShortIf
		|
    	WhileStatementNoShortIf
		|
    	ForStatementNoShortIf
    	;

StatementWithoutTrailingSubstatement::=
    	Block
		|
    	EmptyStatement
		|
    	ExpressionStatement
		|
    	SwitchStatement
		|
    	DoStatement
		|
    	BreakStatement
		|
    	ContinueStatement
		|
    	ReturnStatement
		|
    	SynchronizedStatement
		|
    	ThrowStatement
		|
    	TryStatement
    	;

EmptyStatement::=
		SEMICOLON
    	;

LabeledStatement::=
    	Identifier COLON Statement
    	;

LabeledStatementNoShortIf::=
    	Identifier COLON StatementNoShortIf
    	;

ExpressionStatement::=
    	StatementExpression SEMICOLON
    	;

StatementExpression::=
    	Assignment
		|
    	PreIncrementExpression
		|
    	PreDecrementExpression
		|
    	PostIncrementExpression
		|
    	PostDecrementExpression
		|
    	MethodInvocation
		|
    	ClassInstanceCreationExpression
		;
		
IfThenStatement::=
    	IF LPAREN Expression RPAREN Statement
    	;

IfThenElseStatement::=
    	IF LPAREN Expression RPAREN StatementNoShortIf ELSE Statement
    	;

IfThenElseStatementNoShortIf::=
    	IF LPAREN Expression RPAREN StatementNoShortIf ELSE StatementNoShortIf
		;
		
SwitchStatement::=
    	SWITCH LPAREN Expression RPAREN SwitchBlock
    	;

SwitchBlock::=
    	LBRACE SwitchBlockStatementGroups SwitchLabels RBRACE
    	|
    	LBRACE SwitchBlockStatementGroups  RBRACE
    	|
    	LBRACE SwitchLabels RBRACE
    	|
    	LBRACE RBRACE
    	;

SwitchBlockStatementGroups::=
    	SwitchBlockStatementGroup
		|
    	SwitchBlockStatementGroups SwitchBlockStatementGroup
    	;

SwitchBlockStatementGroup::=
    	SwitchLabels BlockStatements
    	;

SwitchLabels::=
    	SwitchLabel
		|
    	SwitchLabels SwitchLabel
    	;

SwitchLabel::=
    	CASE ConstantExpression COLON
		|
    	DEFAULT COLON
    	;

WhileStatement::=
    	WHILE LPAREN Expression RPAREN Statement
    	;

WhileStatementNoShortIf::=
    	WHILE LPAREN Expression RPAREN StatementNoShortIf
    	;

DoStatement::=
    	DO Statement WHILE LPAREN Expression RPAREN SEMICOLON
    	;

ForStatement::=
    	FOR LPAREN ForVarControl RPAREN Statement
    	;

ForStatementNoShortIf::=
    	FOR LPAREN ForVarControl RPAREN StatementNoShortIf
    	;

ForVarControl::=
		ForInit_opt SEMICOLON Expression_opt SEMICOLON ForUpdate_opt
		|
		LocalVariableDeclaration COLON Expression
		;


ForInit_opt::=
	|
	ForInit 
	;
	 
Expression_opt::=
	|
	Expression 
	; 
	
ForUpdate_opt::=
	|
	ForUpdate
	;


ForInit::=
    	StatementExpressionList
		|
    	LocalVariableDeclaration
    	;

ForUpdate::=
    	StatementExpressionList
    	;

StatementExpressionList::=
    	StatementExpression
		|
    	StatementExpressionList COMMA StatementExpression
    	;


Identifier_opt::= 
		Identifier:i  {: RESULT = i; :}
		|
		{: RESULT = ""; :}
		;
BreakStatement::=
    	BREAK Identifier_opt:o SEMICOLON 		{: RESULT = "break "+o+"; "; :}
    	;
ContinueStatement::=
    	CONTINUE Identifier_opt:o SEMICOLON		{: RESULT = "continue "+o+"; "; :}
    	;

ReturnStatement::=
    	RETURN Expression_opt:o SEMICOLON		{: RESULT = "return"+o+"; "; :}
    	;

ThrowStatement::=
    	THROW Expression:o SEMICOLON			{: RESULT = "throw "+o+"; "; :}
    	;

SynchronizedStatement::=
    	SYNCHRONIZED LPAREN Expression:e RPAREN Block:b	{: RESULT = "synchronized ("+e+")"+b; :}
    	;

TryStatement::=
    	TRY Block Catches											{: RESULT = "TryStatement-1"; :}
		|
    	TRY Block Catches_opt Finally								{: RESULT = "TryStatement-2"; :}
    	|
    	TRY LPAREN TryResources RPAREN Block Catches				{: RESULT = "TryStatement-3"; :}
    	|
    	TRY LPAREN TryResources RPAREN Block Catches_opt Finally	{: RESULT = "TryStatement-4"; :}
		|
		TRY LPAREN TryResources RPAREN Block						{: RESULT = "TryStatement-5"; :}
    	;
    	
TryResources::= Resource						{: RESULT = "TryResources-1"; :}
		|
		TryResources SEMICOLON Resource			{: RESULT = "TryResources-2"; :}
		; 

Resource::=
    Modifiers_opt Type VariableDeclaratorId BECOMES Expression {: RESULT = "Resource-1"; :}		
    ;     	
    	

Catches_opt::=	/* empty */ {: RESULT = "Catches_opt-1 (empty)"; :}	
		|
		Catches				{: RESULT = "Catches_opt-2"; :}	
		;

Catches::=
    	CatchClause			{: RESULT = "Catches-1"; :}	
		|
    	Catches CatchClause {: RESULT = "Catches-2"; :}
    	;

CatchClause::=
    	CATCH LPAREN CatchTypes VariableDeclaratorId RPAREN Block  		{: RESULT = "CatchClause-2"; :}
    	;

CatchTypes::= Type
		|
		CatchTypes OR Type							{: RESULT = "CatchTypes-1"; :}
		;  	

Finally::=
    	FINALLY Block								{: RESULT = "Finally-1"; :}
    	;

    	
    /* ********************** EXPRESSION & derivatives ********************************* */  	  	

Expression::=
		LambdaExpression:e		{: RESULT = e; :}
		|
    	AssignmentExpression:e	{: RESULT = e; :}    	
    	;    	
    	
LambdaExpression::=
    LambdaParameters:p ARROW LambdaBody:e	{: RESULT = p+" -> "+e; :}
    |
    IDENTIFIER:p ARROW LambdaBody:e			{: RESULT = p+" -> "+e; :}     
    ;
LambdaParameters::=
    LPAREN RPAREN							{: RESULT = "()"; :}
    |
    LPAREN IDENTIFIER:e RPAREN			{: RESULT = "("+e+")"; :}
	|
    LPAREN IdentifierList:e RPAREN			{: RESULT = "("+e+")"; :}    
    ;
IdentifierList::=	
	IdentifierList:o COMMA IDENTIFIER:e		{: RESULT = o+", "+e; :}
	|
	{: RESULT = ""; :}
	;	    
LambdaBody::=
    Expression:e					{: RESULT = e; :}
    | 
    Block:e							{: RESULT = e; :}
    ;
AssignmentExpression::=
    	ConditionalExpression
		|
    	Assignment
    	;
ConditionalExpression::=
    	ConditionalOrExpression
		|
    	ConditionalOrExpression QUESTION Expression COLON ConditionalExpression
    	;
Assignment::=
    	LeftHandSide AssignmentOperator AssignmentExpression
    	;
LeftHandSide::=
	   	Name
		|
    	FieldAccess
		|
    	ArrayAccess
    	;
AssignmentOperator::= 
	    BECOMES:i 		{: RESULT = i; :}
	    | 
	    PLUS_EQUALS:i 	{: RESULT = i; :}
	    |
	    MINUS_EQUALS:i 	{: RESULT = i; :}
	    |
	    TIMES_EQUALS:i 	{: RESULT = i; :}
	    |
	    DIV_EQUALS:i 	{: RESULT = i; :}
	    |
	    AND_EQUALS:i 	{: RESULT = i; :}
	    |
	    OR_EQUALS:i 	{: RESULT = i; :}
	    |
	    XOR_EQUALS:i 	{: RESULT = i; :}
	    |
	    MOD_EQUALS:i 	{: RESULT = i; :}
	    |
		SHIFT_LEFT_EQUALS:i 	{: RESULT = i; :}
		|
		SHIFT_RIGHT_EQUALS:i 	{: RESULT = i; :}
		|
		SHIFT_RIGHT_ARITHM_EQUALS:i {: RESULT = i; :}
		;
FieldAccess::=
    	Primary:p DOT Identifier:i 		{: RESULT = "FieldAccess "+p+"."+i; :}
		|
    	SUPER DOT Identifier:i		{: RESULT = "FieldAccess super."+i; :}
    	;

MethodInvocation::=
    	Name LPAREN ArgumentList_opt RPAREN
		|
    	Primary DOT Identifier LPAREN ArgumentList_opt RPAREN
		|
    	SUPER DOT Identifier LPAREN ArgumentList_opt RPAREN
    	;


PostfixExpression::=
    	Primary
		|
    	Name
		|
    	PostIncrementExpression
		|
    	PostDecrementExpression
    	;

PostIncrementExpression::=
    	PostfixExpression INC
		;
		
PostDecrementExpression::=
    	PostfixExpression DEC
    	;

UnaryExpression::=
    	PreIncrementExpression
		|
    	PreDecrementExpression
		|
    	PLUS UnaryExpression
		|
    	MINUS UnaryExpression
		|
    	UnaryExpressionNotPlusMinus
    	;

PreIncrementExpression::=
    	INC UnaryExpression
    	;

PreDecrementExpression::=
    	DEC UnaryExpression
    	;

UnaryExpressionNotPlusMinus::=
    	PostfixExpression
		|
    	BITWISE_NOT UnaryExpression
		|
    	NOT UnaryExpression
    	|
    	CastExpression
    	;

CastExpression::=
    	LPAREN PrimitiveType Dims_opt RPAREN UnaryExpression
		|
    	LPAREN Expression RPAREN UnaryExpressionNotPlusMinus
		|
    	LPAREN Name Dims RPAREN UnaryExpressionNotPlusMinus
    	;

MultiplicativeExpression::=
    	UnaryExpression
		|
    	MultiplicativeExpression TIMES UnaryExpression
		|
    	MultiplicativeExpression DIVIDE UnaryExpression
		|
    	MultiplicativeExpression MOD UnaryExpression
    	;

AdditiveExpression::=
    	MultiplicativeExpression
		|
    	AdditiveExpression PLUS MultiplicativeExpression
		|
    	AdditiveExpression MINUS MultiplicativeExpression
    	;

ShiftExpression::=
    	AdditiveExpression
		|
    	ShiftExpression SHIFT_LEFT AdditiveExpression
		|
    	ShiftExpression SHIFT_RIGHT AdditiveExpression
		|
    	ShiftExpression SHIFT_RIGHT_ARITHM AdditiveExpression
    	;

RelationalExpression::=
    	ShiftExpression
		|
    	RelationalExpression LT ShiftExpression
		|
    	RelationalExpression GT ShiftExpression
		|
    	RelationalExpression LE ShiftExpression
		|
    	RelationalExpression GE ShiftExpression
		|
    	RelationalExpression INSTANCEOF ReferenceType
    	;

EqualityExpression::=
    	RelationalExpression
		|
    	EqualityExpression EQUALS RelationalExpression
		|
    	EqualityExpression NOT_EQUALS RelationalExpression
    	;

AndExpression::=
    	EqualityExpression
		|
    	AndExpression AND EqualityExpression
    	;

ExclusiveOrExpression::=
    	AndExpression
		|
    	ExclusiveOrExpression XOR AndExpression
    	;

InclusiveOrExpression::=
    	ExclusiveOrExpression
		|
    	InclusiveOrExpression OR ExclusiveOrExpression
    	;

ConditionalAndExpression::=
    	InclusiveOrExpression
		|
    	ConditionalAndExpression DOUBLE_AND InclusiveOrExpression
    	;

ConditionalOrExpression::=
    	ConditionalAndExpression
		|
    	ConditionalOrExpression DOUBLE_OR ConditionalAndExpression
    	;		
Primary::=
    	PrimaryNoNewArray
		|
    	ArrayCreationExpression
    	;

PrimaryNoNewArray::=
    	Literal								{: RESULT = "PrimaryNoNewArray-1"; :}
		|
    	THIS								{: RESULT = "PrimaryNoNewArray-2"; :}
		|	
    	LPAREN Expression RPAREN			{: RESULT = "PrimaryNoNewArray-3"; :}
		|
    	ClassInstanceCreationExpression		{: RESULT = "PrimaryNoNewArray-4"; :}
		|
    	FieldAccess							{: RESULT = "PrimaryNoNewArray-5"; :}
		|
    	MethodInvocation					{: RESULT = "PrimaryNoNewArray-6"; :}
		|
    	ArrayAccess							{: RESULT = "PrimaryNoNewArray-7"; :}
    	;


ClassInstanceCreationExpression::=
    	NEW ClassType LPAREN ArgumentList_opt RPAREN	{: RESULT = "ClassInstanceCreationExpression-1"; :}
    	;

    	
    	
Literal::=
	INTEGER_LITERAL:i 				{: RESULT = ""+i; :}
	|
	FLOATING_POINT_LITERAL:i 		{: RESULT = ""+i; :}
	|
	TRUE:i 							{: RESULT = ""+i; :} 
	| 
	FALSE:i 						{: RESULT = ""+i; :}
	|
	NULL:i 							{: RESULT = ""+i; :}
	|
	CHARACTER_LITERAL:i 			{: RESULT = "'"+i+"'"; :}
	|
	STRING_LITERAL:i 				{: RESULT = "\""+i+"\""; :}
	;
	

Dims_opt::=
		Dims_opt:o Dims:i		{: RESULT = o+""+i; :}
		|
		{: RESULT = ""; :}
		;
Dims::=
    	LBRACKET RBRACKET {: RESULT = "[]"; :}
		;
		
DimExprs::=
		DimExprs:o DimExpr:i	{: RESULT = o+""+i; :}
		|
    	DimExpr:i				{: RESULT = i; :}				
    	;
DimExpr::=
    	LBRACKET Expression:i RBRACKET	{: RESULT = "["+i+"]"; :}
    	;
    	