package Parser;

import java.util.*;
import java_cup.runtime.*;


/* Terminals (tokens returned by the scanner) */
/* declarations */		
terminal	PACKAGE	;
terminal	IMPORT	;
terminal	CLASS	;
terminal	ENUM	;
terminal	INTERFACE	;
terminal	EXTENDS	;
terminal	IMPLEMENTS	;
terminal	INSTANCEOF;
		
		
/* types */		
terminal	BYTE	;
terminal	SHORT	;
terminal	CHAR	;
terminal	INT	;
terminal	LONG	;
terminal	FLOAT	;
terminal	DOUBLE	;
terminal	BOOLEAN	;
		
		
terminal	VOID	;
terminal	THIS	;
terminal	SUPER	;
terminal	NEW	;
terminal	TRUE	;
terminal	FALSE	;
terminal	NULL	;
		
		
/* control flow */		
terminal	IF	;
terminal	ELSE	;
terminal	FOR	;
terminal	WHILE	;
terminal	RETURN	;
terminal	DO	;
terminal	ASSERT	;
terminal	SWITCH	;
terminal	CASE	;
terminal	DEFAULT	;
terminal	BREAK	;
terminal	CONTINUE	;
terminal	TRY	;
terminal	CATCH	;
terminal	FINALLY	;
terminal	THROW	;
terminal	THROWS	;
		
		
/* modifiers */		
terminal	PUBLIC	;
terminal	PROTECTED	;
terminal	PRIVATE	;
terminal	STATIC	;
terminal	ABSTRACT	;
terminal	FINAL	;
terminal	NATIVE	;
terminal	SYNCHRONIZED	;
terminal	TRANSIENT	;
terminal	VOLATILE	;
terminal	STRICTFP	;
		
		
/* literals */		
terminal	INTEGER_LITERAL	;
terminal    STRING_LITERAL;
		
/* operators */		
terminal	GE	;
terminal	LE	;
terminal	EQUALS	;
terminal	NOT_EQUALS	;
terminal	DOUBLE_OR	;
terminal	DOUBLE_AND	;
terminal	SHIFT_LEFT	;
terminal	SHIFT_RIGHT	;
terminal	SHIFT_RIGHT_ARITHM	;
terminal	INC	;
terminal	DEC	;
		
		
terminal	PLUS	;
terminal	MINUS	;
terminal	TIMES	;
terminal	DIVIDE	;
terminal	NOT	;
terminal	AND	;
terminal	OR	;
terminal	XOR	;
terminal	MOD	;
terminal	BITWISE_NOT	;		
terminal	HASH	;
terminal	BACKSLASH	;
		
/* assignments */		
terminal	PLUS_EQUALS	;
terminal	MINUS_EQUALS	;
terminal	TIMES_EQUALS	;
terminal	DIV_EQUALS	;
terminal	AND_EQUALS	;
terminal	OR_EQUALS	;
terminal	XOR_EQUALS	;
terminal	MOD_EQUALS	;
terminal	SHIFT_LEFT_EQUALS	;
terminal	SHIFT_RIGHT_EQUALS	;
terminal	SHIFT_RIGHT_ARITHM_EQUALS	;
terminal	BECOMES	;
		
    		
/* delimiters */		
terminal	LPAREN	;
terminal	RPAREN	;
terminal	LBRACKET	;
terminal	RBRACKET	;
terminal	LBRACE	;
terminal	RBRACE	;
terminal	LT	;
terminal	GT	;
terminal	QUOTE	;
		
		
/* punctuation */		
terminal    ELLIPSIS;
terminal	DOT	;
terminal	COMMA	;
terminal	SEMICOLON	;
terminal	COLON	;
terminal	QUESTION	;
terminal    AT ; 

/* identifiers */		
terminal	IDENTIFIER	;


/* Nonterminals */
nonterminal CompilationUnit;
nonterminal Annotations;
nonterminal QualifiedIdentifier;
nonterminal ImportDeclaration;
nonterminal ImportDeclarations;
nonterminal TypeDeclaration;
nonterminal TypeDeclarations;
nonterminal PackageDeclaration;
nonterminal Annotation;
nonterminal Identifier;
nonterminal AnnotationElement;
nonterminal ClassDeclaration;
nonterminal InterfaceDeclaration;
nonterminal ClassOrInterfaceDeclaration;
nonterminal Modifiers;
nonterminal Modifier;
nonterminal ElementValuePairs;
nonterminal ElementValuePair;
nonterminal ElementValues;
nonterminal ElementValue;
nonterminal ElementValueArrayInitializer;
nonterminal NormalClassDeclaration;
nonterminal EnumDeclaration;
nonterminal NormalInterfaceDeclaration;
nonterminal AnnotationTypeDeclaration;
nonterminal Type;
nonterminal BasicType; 
nonterminal ReferenceType;
nonterminal TypeArguments; 
nonterminal TypeArgument;  
nonterminal TypeArgumentList;
nonterminal NonWildcardTypeArguments;
nonterminal TypeList;  
nonterminal TypeArgumentsOrDiamond;
nonterminal NonWildcardTypeArgumentsOrDiamond;
nonterminal TypeParameters;
nonterminal TypeParameter;
nonterminal TypeParameterList;
nonterminal Bound;  
nonterminal EmptyArrays;
nonterminal EmptyArray;
nonterminal ClassBody;
nonterminal InterfaceBody;
nonterminal AnnotationTypeBody;
nonterminal EnumBody;
nonterminal EnumConstants;
nonterminal EnumConstant;
nonterminal EnumBodyDeclarations;
nonterminal ExpressionList;
nonterminal Arguments;
nonterminal AnnotationTypeElementDeclarations;
nonterminal AnnotationTypeElementDeclaration;
nonterminal AnnotationTypeElementRest;
nonterminal AnnotationMethodOrConstantRest;
nonterminal AnnotationMethodRest;
nonterminal ConstantDeclaratorsRest;
nonterminal ConstantDeclaratorRest;
nonterminal VariableInitializer;
nonterminal ConstantDeclarator;
nonterminal ArrayInitializer;
nonterminal VariableInitializerList;
nonterminal Expression;
nonterminal AssignmentOperator;
nonterminal Expression1;
nonterminal Expression1Rest	;
nonterminal Expression2;
nonterminal Expression2Rest;
nonterminal Expression3List;
nonterminal InfixOp;
nonterminal Expression3;
nonterminal PrefixOp;
nonterminal PostfixOp;

nonterminal Primary ;
nonterminal Literal;
nonterminal ParExpression;
nonterminal IntegerLiteral;
nonterminal CharacterLiteral ;
nonterminal StringLiteral ;
nonterminal BooleanLiteral;
nonterminal NullLiteral;
nonterminal Selector;
nonterminal SuperSuffix;

nonterminal MethodOrFieldDecl;
nonterminal VoidMethodDeclaratorRest;
nonterminal ConstructorDeclaratorRest;
nonterminal GenericMethodOrConstructorDecl;
nonterminal MethodOrFieldRest  ;
nonterminal FieldDeclaratorsRest;
nonterminal MethodDeclaratorRest;
nonterminal ClassBodyDeclarationList;
nonterminal ClassBodyDeclaration;
nonterminal MemberDecl;
nonterminal VariableDeclaratorRest;
nonterminal VariableDeclarator;
nonterminal OptionalThrowsQualifiedIdentifierList;
nonterminal QualifiedIdentifierList;
nonterminal FormalParameters;
nonterminal GenericMethodOrConstructorRest;
nonterminal ExplicitGenericInvocation;
nonterminal ExplicitGenericInvocationSuffix;
nonterminal InnerCreator;
nonterminal OptionalDotIdentifierList;
nonterminal Creator;
nonterminal IdentifierSuffix;
nonterminal FormalParameterDecls;
nonterminal VariableModifierList;
nonterminal VariableModifier;
nonterminal FormalParameterDeclsRest;
nonterminal VariableDeclaratorId;

nonterminal Block;
nonterminal BlockStatements;
nonterminal BlockStatement;
nonterminal LocalVariableDeclarationStatement;
nonterminal Statement;
nonterminal SwitchBlockStatementGroups;
nonterminal CatchClause;
nonterminal CatchType;
nonterminal Catches ;
nonterminal Finally ;
nonterminal ResourceSpecification; 
nonterminal SwitchBlockStatementGroup; 
nonterminal SwitchLabels;
nonterminal SwitchLabel;
nonterminal EnumConstantName;
nonterminal StatementExpression;
nonterminal ForControl;
nonterminal ForVarControl;
nonterminal ForVarControlRest;
nonterminal ForVariableDeclaratorsRest;
nonterminal OptionalVariableInitializer;
nonterminal VariableDeclaratorList ;
nonterminal ForInit;
nonterminal ForUpdate;
nonterminal Resources;
nonterminal Resource;
nonterminal VariableDeclarators;





/* Precedence declarations */
/* The last precedence declaration give its terminals the highest precedence */
/* https://introcs.cs.princeton.edu/java/11precedence/ */

/* precedence right lambda -> */
precedence right BECOMES, PLUS_EQUALS, MINUS_EQUALS, TIMES_EQUALS, DIV_EQUALS, MOD_EQUALS, AND_EQUALS, XOR_EQUALS, OR_EQUALS, SHIFT_LEFT_EQUALS, SHIFT_RIGHT_EQUALS, SHIFT_RIGHT_ARITHM_EQUALS; /* level 1*/
precedence left QUESTION, COLON; 		/* level 2*/
precedence left DOUBLE_OR; 				/* level 3*/
precedence left DOUBLE_AND; 			/* level 4*/
precedence left OR; 					/* level 5*/
precedence left XOR; 					/* level 6*/
precedence left AND; 					/* level 7*/
precedence left EQUALS, NOT_EQUALS; 	/* LEVEL 8 */
precedence left LT, GT, LE, GE, INSTANCEOF;   					/* LEVEL 9 */
precedence left SHIFT_LEFT, SHIFT_RIGHT, SHIFT_RIGHT_ARITHM;   	/* LEVEL 10 */
precedence left PLUS, MINUS; 			/* LEVEL 11 */
precedence left TIMES, DIVIDE, MOD; 	/* LEVEL 12 */
precedence right NOT, BITWISE_NOT;		/* LEVEL 14 + UNARY PLUS MINUS PREINC, PREDEC */
precedence nonassoc AT;					/* ? */
precedence left INC, DEC; 				/* LEVEL 15*/
precedence left LPAREN, RPAREN, LBRACE, RBRACE, NEW, DOT; 		/*LEVEL 16, + METHOD REFERENCE :: */





/* Productions */

CompilationUnit::= PackageDeclaration ImportDeclarations TypeDeclarations
				|
				PackageDeclaration TypeDeclarations
				|
				ImportDeclarations TypeDeclarations
				|
				TypeDeclarations
				;

PackageDeclaration::= Annotations PACKAGE QualifiedIdentifier SEMICOLON
				|
				PACKAGE QualifiedIdentifier SEMICOLON
				;

QualifiedIdentifier::= Identifier 
 				|
				QualifiedIdentifier DOT Identifier
				;

Annotations::= Annotation 
				|
				Annotations Annotation
				;   

Annotation::= AT QualifiedIdentifier LPAREN AnnotationElement RPAREN
				|
				AT QualifiedIdentifier LPAREN RPAREN
				|
				AT QualifiedIdentifier				
				;

AnnotationElement::=
		    ElementValuePairs
		    |
		    ElementValue
		    ;

ElementValuePairs::= ElementValuePair 
			|
			ElementValuePairs COMMA ElementValuePair
			;

ElementValuePair::= Identifier BECOMES ElementValue
			;
    
ElementValue::=  Annotation
			|
		    Expression1 
		    |
		    ElementValueArrayInitializer
		    ;


ElementValueArrayInitializer::= LBRACE ElementValues COMMA RBRACE
			|
			LBRACE ElementValues RBRACE
			|
			LBRACE COMMA RBRACE
			|
			LBRACE RBRACE
			;


ElementValues ::= ElementValue 
			|
			ElementValues COMMA	ElementValue
			;
				
				
				
				
				
				
ImportDeclarations ::= ImportDeclaration
				|
				ImportDeclarations ImportDeclaration
				;					
					
ImportDeclaration::= IMPORT STATIC QualifiedIdentifier DOT TIMES SEMICOLON
				|
				IMPORT STATIC QualifiedIdentifier SEMICOLON
				|
				IMPORT QualifiedIdentifier DOT TIMES SEMICOLON
				|
				IMPORT QualifiedIdentifier SEMICOLON
				;

TypeDeclarations::= TypeDeclaration
				|
				TypeDeclarations TypeDeclaration
				;

TypeDeclaration::= Modifiers ClassOrInterfaceDeclaration
				|
				ClassOrInterfaceDeclaration
				;

ClassOrInterfaceDeclaration::=  
				ClassDeclaration 
				| 
				InterfaceDeclaration
				;

Modifiers::= Modifier Modifiers
			|
			Modifier;

Modifier::=
    Annotations
    | PUBLIC
    | PROTECTED
    | PRIVATE
    | STATIC 
    | ABSTRACT
    | FINAL
    | NATIVE
    | SYNCHRONIZED
    | TRANSIENT
    | VOLATILE
    | STRICTFP
    ;





ClassDeclaration::= NormalClassDeclaration
				|
			    EnumDeclaration
			    ;


InterfaceDeclaration::= NormalInterfaceDeclaration
				|
			    AnnotationTypeDeclaration
			    ;
			    
			    
NormalClassDeclaration::= CLASS Identifier TypeParameters EXTENDS Type IMPLEMENTS TypeList ClassBody
				|
				CLASS Identifier EXTENDS Type IMPLEMENTS TypeList ClassBody
				|
				CLASS Identifier TypeParameters IMPLEMENTS TypeList ClassBody
				|
				CLASS Identifier TypeParameters EXTENDS Type ClassBody
				|
				CLASS Identifier IMPLEMENTS TypeList ClassBody
				|
				CLASS Identifier EXTENDS Type ClassBody
				|
				CLASS Identifier TypeParameters ClassBody
				|
				CLASS Identifier ClassBody
				;

EnumDeclaration::= ENUM Identifier IMPLEMENTS TypeList EnumBody
				|
				ENUM Identifier EnumBody
				;

NormalInterfaceDeclaration::=  INTERFACE Identifier TypeParameters EXTENDS TypeList InterfaceBody
				|
				INTERFACE Identifier EXTENDS TypeList InterfaceBody
				|
				INTERFACE Identifier TypeParameters InterfaceBody
				|
				INTERFACE Identifier InterfaceBody
				;





AnnotationTypeDeclaration::= AT INTERFACE Identifier AnnotationTypeBody ;
				
EmptyArrays::= EmptyArray
			|
			EmptyArrays EmptyArray
			;				

EmptyArray::= LBRACKET RBRACKET;
				
Type::=
    BasicType EmptyArrays
    |
    ReferenceType EmptyArrays
    |
    BasicType 
    |
    ReferenceType 
    ;

BasicType::= 
    BYTE
    |
    SHORT
    |
    CHAR
    |
    INT
    |
    LONG
    |
    FLOAT
    |
    DOUBLE
    |
    BOOLEAN
    ;

ReferenceType::=  Identifier TypeArguments DOT ReferenceType
			|
			Identifier DOT ReferenceType
			|
			Identifier TypeArguments 
			|
			Identifier
			;


TypeArguments ::= LT TypeArgumentList GT;

TypeArgumentList ::= TypeArgument
			|
			TypeArgumentList COMMA TypeArgument
			;


TypeArgument::=  QUESTION EXTENDS ReferenceType
			|
			ReferenceType
			;


NonWildcardTypeArguments::= GT TypeList LT;

TypeList::=  ReferenceType
			|
			COMMA TypeList
			;

TypeArgumentsOrDiamond::=
    LT GT 
    |
    TypeArguments
    ;

NonWildcardTypeArgumentsOrDiamond::=
    LT GT
    |
    NonWildcardTypeArguments
    ;


TypeParameters::= LT TypeParameterList GT    	;

TypeParameterList::= TypeParameter
			|
			TypeParameterList COMMA TypeParameter
			;

TypeParameter::=
    Identifier EXTENDS Bound
    |
    Identifier
    ;

Bound::=  
    ReferenceType
    | 
	AND Bound
	;







EnumBody::=
    LBRACE EnumConstants COMMA EnumBodyDeclarations RBRACE
    |
    LBRACE COMMA EnumBodyDeclarations RBRACE
    |
    LBRACE EnumConstants EnumBodyDeclarations RBRACE
    |
    LBRACE EnumConstants COMMA RBRACE
    |
    LBRACE EnumBodyDeclarations RBRACE
    |
    LBRACE EnumConstants RBRACE
    |
    LBRACE COMMA RBRACE
    |
    LBRACE RBRACE
    ;

EnumConstants::=
    EnumConstant
    |
    EnumConstants COMMA EnumConstant
    ;

EnumConstant::=
    Annotations Identifier Arguments ClassBody
    |
    Annotations Identifier ClassBody
    |
    Annotations Identifier Arguments
    |
    Annotations Identifier 
    |
    Identifier Arguments ClassBody
    |
    Identifier ClassBody
    |
    Identifier Arguments
    |
    Identifier
    ;


EnumBodyDeclarations::=
    SEMICOLON
    |
	SEMICOLON ClassBody
    ;



AnnotationTypeBody::=
    LBRACE AnnotationTypeElementDeclarations RBRACE
    |
    LBRACE RBRACE
    ;

AnnotationTypeElementDeclarations::=
    AnnotationTypeElementDeclaration
    |
    AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
    ;

AnnotationTypeElementDeclaration::=
    Modifiers AnnotationTypeElementRest  /* mudei aqui em relação ao original modifier */
    |
    AnnotationTypeElementRest
    ;

AnnotationTypeElementRest::=
    Type Identifier AnnotationMethodOrConstantRest SEMICOLON
    
    /* FIXME
    |
    ClassDeclaration
    |
    InterfaceDeclaration
    |
    EnumDeclaration  
    |
    AnnotationTypeDeclaration    
    */
    ;

AnnotationMethodOrConstantRest::=
    AnnotationMethodRest
    |
    ConstantDeclaratorRest  /* era ConstantDeclaratorsRest */
    ;

AnnotationMethodRest::=
    LPAREN RPAREN LBRACKET RBRACKET DEFAULT ElementValue
    |
    LPAREN RPAREN DEFAULT ElementValue
    |
    LPAREN RPAREN LBRACKET RBRACKET
    |
    LPAREN RPAREN 
    ;
    
ConstantDeclaratorsRest::=
	ConstantDeclarator	
	|
    ConstantDeclaratorRest COMMA ConstantDeclarator
    ;

ConstantDeclaratorRest::=
    LBRACKET RBRACKET BECOMES VariableInitializer
    |
    BECOMES VariableInitializer
    ;

ConstantDeclarator::= Identifier ConstantDeclaratorRest;


VariableInitializer::=
    ArrayInitializer
    |
    Expression
    ;

VariableInitializerList::= VariableInitializer
	|
	VariableInitializerList COMMA VariableInitializer
	;


ArrayInitializer::=
    LBRACE VariableInitializerList COMMA RBRACE
    |
    LBRACE VariableInitializerList RBRACE
	;

Expression::= Expression1
		|
		Expression1 AssignmentOperator Expression1
		;

AssignmentOperator::=
    BECOMES
    | 
    PLUS_EQUALS
    |
    MINUS_EQUALS
    |
    TIMES_EQUALS
    |
    DIV_EQUALS
    |
    AND_EQUALS
    |
    OR_EQUALS
    |
    XOR_EQUALS
    |
    MOD_EQUALS
    |
	SHIFT_LEFT_EQUALS
	|
	SHIFT_RIGHT_EQUALS
	|
	SHIFT_RIGHT_ARITHM_EQUALS
	;
	
	
Expression1::=
    Expression2 Expression1Rest
    |
    Expression2
    ;

Expression1Rest::= QUESTION Expression COLON Expression1;	

Expression2::= Expression3 Expression2Rest;

Expression2Rest::= /* empty */
	|
    Expression3List
    |
    INSTANCEOF Type	
    ;
    
Expression3List::= InfixOp Expression3 
	|
	Expression3List InfixOp Expression3
	;
    
InfixOp::=
	DOUBLE_OR
	|
	DOUBLE_AND
	|
	AND
	|
	OR
	|
	XOR
	|
	EQUALS
	|
	NOT_EQUALS
	|
	LT
	|
	GT    
	|
	GE
	|
	LE
	|
	SHIFT_LEFT
	|
	SHIFT_RIGHT
	|
	SHIFT_RIGHT_ARITHM
	|
	PLUS
	|
	MINUS
	|
	TIMES
	|
	DIVIDE
	|
	MOD
	;


Expression3::=
	/* FIXME
    PrefixOp Expression3
    |
    */
    LPAREN Expression RPAREN Expression3
    |
    LPAREN Type RPAREN Expression3
    |
    Primary Selector PostfixOp
    |
    Primary Selector
    |
	Primary PostfixOp
	|
	Primary
	;

PrefixOp::= 
		PostfixOp
		|
		NOT
		|
		BITWISE_NOT
		|
		PLUS
		|
		MINUS
		;
    

PostfixOp::=
			INC
			|
			DEC
			;
			
			
Primary::= 
    Literal
    |
    ParExpression
    |
    THIS
    |
    THIS Arguments
    |
    SUPER SuperSuffix
    |   
    NEW Creator
    |    
    NonWildcardTypeArguments LPAREN ExplicitGenericInvocationSuffix RPAREN
    |
    NonWildcardTypeArguments LPAREN THIS Arguments RPAREN
    |
    Identifier OptionalDotIdentifierList IdentifierSuffix
	|   
	Identifier OptionalDotIdentifierList
	|   	
	BasicType EmptyArrays DOT CLASS
    |
    BasicType DOT CLASS
    |
    VOID DOT CLASS
    ;

OptionalDotIdentifierList::= /* empty */
			|
			DOT Identifier
			;
	

Literal::=
    IntegerLiteral
    |
    /* FloatingPointLiteral */
    CharacterLiteral 
    |
    StringLiteral 
    |
    BooleanLiteral
    |
    NullLiteral
    ;

IntegerLiteral::= INTEGER_LITERAL;

CharacterLiteral::= QUOTE Identifier QUOTE;

StringLiteral::= STRING_LITERAL;

BooleanLiteral::= TRUE | FALSE;

NullLiteral::= NULL;


ParExpression::= LPAREN Expression RPAREN;

ExpressionList::= Expression
		|
		ExpressionList COMMA Expression
		;
		
Arguments::=  LPAREN ExpressionList RPAREN;


Selector::=
    DOT Identifier
    |
    DOT Identifier Arguments
    |
    DOT ExplicitGenericInvocation
    |
    DOT THIS
    |
    DOT SUPER SuperSuffix
    |
    DOT NEW NonWildcardTypeArguments InnerCreator
    |
    DOT NEW InnerCreator
    |
    Expression
	;

SuperSuffix::=
    Arguments 
    |
    DOT Identifier Arguments
    |
    DOT Identifier
    ;
    

ExplicitGenericInvocationSuffix::=
    SUPER SuperSuffix
    |
    Identifier Arguments			
    ;
		

		
			
ClassBody::= LBRACE ClassBodyDeclarationList RBRACE;


ClassBodyDeclarationList::= /* empty */
			|
			ClassBodyDeclarationList ClassBodyDeclaration
			;
			
ClassBodyDeclaration::=     SEMICOLON
	|
    Modifiers MemberDecl
    |
    MemberDecl
    |
    STATIC Block			
    |
    Block
    ;


MemberDecl::=
    MethodOrFieldDecl
    |
    VOID Identifier VoidMethodDeclaratorRest
    |
    Identifier ConstructorDeclaratorRest
    |
    GenericMethodOrConstructorDecl
    |
    ClassDeclaration
    |
    InterfaceDeclaration
    ;



MethodOrFieldDecl::= Type Identifier MethodOrFieldRest;

MethodOrFieldRest::=  
    FieldDeclaratorsRest SEMICOLON
    |
    MethodDeclaratorRest
    ;

FieldDeclaratorsRest::=  
    VariableDeclaratorRest
    |
    FieldDeclaratorsRest COMMA VariableDeclarator
    ;

VariableDeclaratorRest::=	/* empty */
	|
	EmptyArrays BECOMES VariableInitializer
	|
	EmptyArrays
	|
	BECOMES VariableInitializer
	;


ArrayInitializer::=
	/* FIXME */
    LBRACKET VariableInitializerList RBRACKET
    |
    LBRACKET RBRACKET
    ;
	

OptionalThrowsQualifiedIdentifierList::= /* empty */
	|
	THROWS QualifiedIdentifierList
	;

QualifiedIdentifierList::=
    QualifiedIdentifier 
    |
    QualifiedIdentifierList COMMA QualifiedIdentifier
	;


MethodDeclaratorRest::=
    FormalParameters EmptyArrays OptionalThrowsQualifiedIdentifierList Block
    |
    FormalParameters EmptyArrays OptionalThrowsQualifiedIdentifierList SEMICOLON
	|
    FormalParameters OptionalThrowsQualifiedIdentifierList Block
    |
    FormalParameters OptionalThrowsQualifiedIdentifierList SEMICOLON
    ;

VoidMethodDeclaratorRest::=
    FormalParameters OptionalThrowsQualifiedIdentifierList Block
    |
    FormalParameters OptionalThrowsQualifiedIdentifierList SEMICOLON
    ;


ConstructorDeclaratorRest::=
    FormalParameters OptionalThrowsQualifiedIdentifierList Block ;

GenericMethodOrConstructorDecl::=
    TypeParameters GenericMethodOrConstructorRest;


GenericMethodOrConstructorRest::= VOID Identifier MethodDeclaratorRest
	| 
	Type Identifier MethodDeclaratorRest
	|
    Identifier ConstructorDeclaratorRest
    ;


FormalParameters::= LPAREN RPAREN
	| 
    LPAREN FormalParameterDecls RPAREN
    ;

FormalParameterDecls::= 
    VariableModifierList Type FormalParameterDeclsRest;

VariableModifierList ::= /* empty */
	|
	VariableModifierList VariableModifier
	; 	
	

VariableModifier::=
    FINAL
    |
    Annotation
    ;

FormalParameterDeclsRest::= 
    VariableDeclaratorId COMMA FormalParameterDecls
    |
    VariableDeclaratorId
    |
    ELLIPSIS VariableDeclaratorId
    ;



VariableDeclaratorId::= Identifier 
		|
		Identifier EmptyArrays
		;



Block::= LBRACE RBRACE
	|
	LBRACE BlockStatements RBRACE;
	
	
BlockStatements::= BlockStatement
	|
	BlockStatements SEMICOLON BlockStatement
	;	

BlockStatement::=
    LocalVariableDeclarationStatement
    |
    Statement
/*    
    |
    ClassOrInterfaceDeclaration
    |
    Identifier COLON Statement
   */ 
    ;

LocalVariableDeclarationStatement::= VariableModifierList Type VariableDeclarators; /* FIXME a ausencia do modificador de variavel faz pensar que é um Primary... */

Statement::=
    RETURN Expression SEMICOLON
    /*
    |
    RETURN SEMICOLON    
    |
    Block
    |
    SEMICOLON
    |
    Identifier COLON Statement
    |
    StatementExpression SEMICOLON
    |
    IF ParExpression Statement ELSE Statement
    | 
    IF ParExpression Statement
    |
    ASSERT Expression COLON Expression SEMICOLON
    |
    ASSERT Expression SEMICOLON
    |
    SWITCH ParExpression SwitchBlockStatementGroups
    | 
    WHILE ParExpression Statement
    |
    DO Statement WHILE ParExpression SEMICOLON
    |
    FOR LPAREN ForControl RPAREN Statement
    |
    BREAK Identifier SEMICOLON
    |
    BREAK SEMICOLON
    |
    CONTINUE Identifier SEMICOLON
    |
    CONTINUE SEMICOLON
    |
    THROW Expression SEMICOLON
    |
    SYNCHRONIZED ParExpression Block
    |
    TRY Block Catches Finally
    |
    TRY Block Catches
    |
    TRY Block Finally
    |
    TRY ResourceSpecification Block Catches Finally
    |
    TRY ResourceSpecification Block Catches
    |
    TRY ResourceSpecification Block Finally
    |        
    TRY ResourceSpecification Block
    */
    ;


SwitchBlockStatementGroups::= SwitchBlockStatementGroup
	|
	SwitchBlockStatementGroups SwitchBlockStatementGroup
	;
	
SwitchBlockStatementGroup::= 
    SwitchLabels BlockStatements
    ;

SwitchLabels::=
    SwitchLabels SwitchLabel
    |
    SwitchLabel
    ;

SwitchLabel::=
    CASE Expression COLON
    |
    CASE EnumConstantName COLON
    |
    DEFAULT COLON
    ;

EnumConstantName::=
    Identifier
    ;

	 
ForControl::=
    ForVarControl
    |
    ForInit SEMICOLON Expression SEMICOLON ForUpdate
    |
    ForInit SEMICOLON Expression SEMICOLON
    | 
    ForInit SEMICOLON SEMICOLON ForUpdate
    |
    ForInit SEMICOLON SEMICOLON
    ;

ForVarControl::=
    VariableModifierList Type VariableDeclaratorId  ForVarControlRest
    ;

ForVarControlRest::=
    ForVariableDeclaratorsRest SEMICOLON Expression SEMICOLON ForUpdate
    |
    ForVariableDeclaratorsRest SEMICOLON Expression SEMICOLON
    |
    ForVariableDeclaratorsRest SEMICOLON SEMICOLON ForUpdate
    |
    ForVariableDeclaratorsRest SEMICOLON SEMICOLON
    | 
    COLON Expression
    ;

ForVariableDeclaratorsRest::=  OptionalVariableInitializer VariableDeclaratorList;

OptionalVariableInitializer::= /* empty */
	|
	BECOMES VariableInitializer
	;
	

VariableDeclaratorList ::= COMMA VariableDeclarator 
	| 
	VariableDeclaratorList COMMA VariableDeclarator
	;

ForInit::=
 	ForInit COMMA StatementExpression     
 	|
 	StatementExpression
 	;
 
ForUpdate::=
 	ForUpdate COMMA StatementExpression     
 	|
 	StatementExpression
 	;
    
    
ResourceSpecification::=
    LPAREN Resources SEMICOLON RPAREN
    |
    LPAREN Resources RPAREN
    ;

Resources::=
    Resource
    |
    Resources SEMICOLON Resource
    ;

Resource::=
    VariableModifierList ReferenceType VariableDeclaratorId BECOMES Expression
    ; 


StatementExpression::=
    Expression
    ;


VariableDeclarators::=
    VariableDeclarators COMMA VariableDeclarator
    |
    VariableDeclarator
    ;

VariableDeclarator::=
    Identifier VariableDeclaratorRest
    ;



Catches::=
    CatchClause
    |
    Catches CatchClause
    ;

CatchClause::=  
    CATCH LPAREN {VariableModifier} CatchType Identifier RPAREN Block
    ;

CatchType::=
    CatchType OR QualifiedIdentifier
    |
    QualifiedIdentifier
    ;

Finally::=
    FINALLY Block
    ;












InterfaceBody::= LBRACE RBRACE;


Identifier::= IDENTIFIER;
