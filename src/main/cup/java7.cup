package Parser;

import java.util.*;
import java_cup.runtime.*;


/* Terminals (tokens returned by the scanner) */
/* declarations */		
terminal	PACKAGE	;
terminal	IMPORT	;
terminal	CLASS	;
terminal	ENUM	;
terminal	INTERFACE	;
terminal	EXTENDS	;
terminal	IMPLEMENTS	;
terminal	INSTANCEOF;
		
		
/* types */		
terminal	BYTE	;
terminal	SHORT	;
terminal	CHAR	;
terminal	INT	;
terminal	LONG	;
terminal	FLOAT	;
terminal	DOUBLE	;
terminal	BOOLEAN	;
		
		
terminal	VOID	;
terminal	THIS	;
terminal	SUPER	;
terminal	NEW	;
terminal	TRUE	;
terminal	FALSE	;
terminal	NULL	;
		
		
/* control flow */		
terminal	IF	;
terminal	ELSE	;
terminal	FOR	;
terminal	WHILE	;
terminal	RETURN	;
terminal	DO	;
terminal	ASSERT	;
terminal	SWITCH	;
terminal	CASE	;
terminal	DEFAULT	;
terminal	BREAK	;
terminal	CONTINUE	;
terminal	TRY	;
terminal	CATCH	;
terminal	FINALLY	;
terminal	THROW	;
terminal	THROWS	;
		
		
/* modifiers */		
terminal	PUBLIC	;
terminal	PROTECTED	;
terminal	PRIVATE	;
terminal	STATIC	;
terminal	ABSTRACT	;
terminal	FINAL	;
terminal	NATIVE	;
terminal	SYNCHRONIZED	;
terminal	TRANSIENT	;
terminal	VOLATILE	;
terminal	STRICTFP	;
		
		
/* literals */		
terminal	INTEGER_LITERAL	;
terminal    STRING_LITERAL;
terminal 	CHARACTER_LITERAL;
terminal	FLOATING_POINT_LITERAL;
		
/* operators */		
terminal	GE	;
terminal	LE	;
terminal	EQUALS	;
terminal	NOT_EQUALS	;
terminal	DOUBLE_OR	;
terminal	DOUBLE_AND	;
terminal	SHIFT_LEFT	;
terminal	SHIFT_RIGHT	;
terminal	SHIFT_RIGHT_ARITHM	;
terminal	INC	;
terminal	DEC	;
		
		
terminal	PLUS	;
terminal	MINUS	;
terminal	TIMES	;
terminal	DIVIDE	;
terminal	NOT	;
terminal	AND	;
terminal	OR	;
terminal	XOR	;
terminal	MOD	;
terminal	BITWISE_NOT	;		
terminal	HASH	;
terminal	BACKSLASH	;
		
/* assignments */		
terminal	PLUS_EQUALS	;
terminal	MINUS_EQUALS	;
terminal	TIMES_EQUALS	;
terminal	DIV_EQUALS	;
terminal	AND_EQUALS	;
terminal	OR_EQUALS	;
terminal	XOR_EQUALS	;
terminal	MOD_EQUALS	;
terminal	SHIFT_LEFT_EQUALS	;
terminal	SHIFT_RIGHT_EQUALS	;
terminal	SHIFT_RIGHT_ARITHM_EQUALS	;
terminal	BECOMES	;
		
    		
/* delimiters */		
terminal	LPAREN	;
terminal	RPAREN	;
terminal	LBRACKET	;
terminal	RBRACKET	;
terminal	LBRACE	;
terminal	RBRACE	;
terminal	LT	;
terminal	GT	;
		
		
/* punctuation */		
terminal    ELLIPSIS;
terminal	DOT	;
terminal	COMMA	;
terminal	SEMICOLON	;
terminal	COLON	;
terminal	QUESTION	;
terminal    AT ; 

/* identifiers */		
terminal	IDENTIFIER	;


/* Nonterminals */
nonterminal CompilationUnit;
nonterminal Annotations;
nonterminal QualifiedIdentifier;
nonterminal ImportDeclaration;
nonterminal ImportDeclarations;
nonterminal TypeDeclaration;
nonterminal TypeDeclarations;
nonterminal PackageDeclaration;
nonterminal Annotation;
nonterminal Identifier;
nonterminal AnnotationElement;
nonterminal ClassDeclaration;
nonterminal InterfaceDeclaration;
nonterminal ClassOrInterfaceDeclaration;
nonterminal Modifiers;
nonterminal Modifier;
nonterminal ElementValuePairs;
nonterminal ElementValuePair;
nonterminal ElementValues;
nonterminal ElementValue;
nonterminal ElementValueArrayInitializer;
nonterminal NormalClassDeclaration;
nonterminal EnumDeclaration;
nonterminal NormalInterfaceDeclaration;
nonterminal AnnotationTypeDeclaration;
nonterminal Type;
nonterminal BasicType; 
nonterminal ReferenceType;
nonterminal TypeArguments; 
nonterminal TypeArgument;  
nonterminal TypeArgumentList;
nonterminal NonWildcardTypeArguments;
nonterminal TypeList;  
nonterminal TypeArgumentsOrDiamond;
nonterminal NonWildcardTypeArgumentsOrDiamond;
nonterminal TypeParameters;
nonterminal TypeParameter;
nonterminal TypeParameterList;
nonterminal Bound;  
nonterminal EmptyArrays;
nonterminal EmptyArray;
nonterminal ClassBody;
nonterminal InterfaceBody;
nonterminal AnnotationTypeBody;
nonterminal EnumBody;
nonterminal EnumConstants;
nonterminal EnumConstant;
nonterminal EnumBodyDeclarations;
nonterminal ExpressionList;
nonterminal Arguments;
nonterminal AnnotationTypeElementDeclarations;
nonterminal AnnotationTypeElementDeclaration;
nonterminal AnnotationTypeElementRest;
nonterminal AnnotationMethodOrConstantRest;
nonterminal AnnotationMethodRest;
nonterminal ConstantDeclaratorsRest;
nonterminal ConstantDeclaratorRest;
nonterminal VariableInitializer;
nonterminal ConstantDeclarator;
nonterminal ArrayInitializer;
nonterminal VariableInitializerList;
nonterminal Expression;
nonterminal AssignmentOperator;
nonterminal Expression1;
nonterminal Expression1Rest	;
nonterminal Expression2;
nonterminal Expression2Rest;
nonterminal Expression3List;
nonterminal InfixOp;
nonterminal Expression3;
nonterminal PrefixOp;
nonterminal PostfixOp;

nonterminal Primary ;
nonterminal Literal;
nonterminal ParExpression;
nonterminal IntegerLiteral;
nonterminal FloatingPointLiteral;
nonterminal CharacterLiteral ;
nonterminal StringLiteral ;
nonterminal BooleanLiteral;
nonterminal NullLiteral;
nonterminal Selector;
nonterminal SuperSuffix;

nonterminal MethodOrFieldDecl;
nonterminal VoidMethodDeclaratorRest;
nonterminal ConstructorDeclaratorRest;
nonterminal GenericMethodOrConstructorDecl;
nonterminal MethodOrFieldRest  ;
nonterminal FieldDeclaratorsRest;
nonterminal MethodDeclaratorRest;
nonterminal ClassBodyDeclarationList;
nonterminal ClassBodyDeclaration;
nonterminal MemberDecl;
nonterminal VariableDeclaratorRest;
nonterminal VariableDeclarator;
nonterminal OptionalThrowsQualifiedIdentifierList;
nonterminal QualifiedIdentifierList;
nonterminal FormalParameters;
nonterminal GenericMethodOrConstructorRest;
nonterminal ExplicitGenericInvocation;
nonterminal ExplicitGenericInvocationSuffix;
nonterminal InnerCreator;
nonterminal ChainedIdentifier;
nonterminal Creator;
nonterminal IdentifierSuffix;
nonterminal FormalParameterDecls;
nonterminal VariableModifierList;
nonterminal VariableModifier;
nonterminal FormalParameterDeclsRest;
nonterminal VariableDeclaratorId;

nonterminal Block;
nonterminal BlockStatements;
nonterminal BlockStatement;
nonterminal LocalVariableDeclarationStatement;
nonterminal Statement;
nonterminal SwitchBlockStatementGroups;
nonterminal CatchClause;
nonterminal CatchType;
nonterminal Catches ;
nonterminal Finally ;
nonterminal ResourceSpecification; 
nonterminal SwitchBlockStatementGroup; 
nonterminal SwitchLabels;
nonterminal SwitchLabel;
nonterminal EnumConstantName;
nonterminal StatementExpression;
nonterminal ForControl;
nonterminal ForVarControl;
nonterminal ForVarControlRest;
nonterminal ForVariableDeclaratorsRest;
nonterminal OptionalVariableInitializer;
nonterminal VariableDeclaratorList ;
nonterminal ForInit;
nonterminal ForUpdate;
nonterminal Resources;
nonterminal Resource;
nonterminal VariableDeclarators;

	
nonterminal InterfaceBodyDeclaration;  
nonterminal InterfaceMemberDecl;
nonterminal InterfaceMethodOrFieldDecl;
nonterminal InterfaceMethodOrFieldRest;
nonterminal InterfaceMethodDeclaratorRest;	
nonterminal VoidInterfaceMethodDeclaratorRest;
nonterminal InterfaceGenericMethodDecl;
nonterminal InterfaceBodyDeclarationList;
nonterminal CreatedName;
nonterminal ClassCreatorRest;
nonterminal ArrayCreatorRest;



/* Precedence declarations */
/* The last precedence declaration give its terminals the highest precedence */
/* https://introcs.cs.princeton.edu/java/11precedence/ */

/* precedence right lambda -> */
precedence right BECOMES, PLUS_EQUALS, MINUS_EQUALS, TIMES_EQUALS, DIV_EQUALS, MOD_EQUALS, AND_EQUALS, XOR_EQUALS, OR_EQUALS, SHIFT_LEFT_EQUALS, SHIFT_RIGHT_EQUALS, SHIFT_RIGHT_ARITHM_EQUALS; /* level 1*/
precedence left QUESTION, COLON; 		/* level 2*/
precedence left DOUBLE_OR; 				/* level 3*/
precedence left DOUBLE_AND; 			/* level 4*/
precedence left OR; 					/* level 5*/
precedence left XOR; 					/* level 6*/
precedence left AND; 					/* level 7*/
precedence left EQUALS, NOT_EQUALS; 	/* LEVEL 8 */
precedence left LT, GT, LE, GE, INSTANCEOF;   					/* LEVEL 9 */
precedence left SHIFT_LEFT, SHIFT_RIGHT, SHIFT_RIGHT_ARITHM;   	/* LEVEL 10 */
precedence left PLUS, MINUS; 			/* LEVEL 11 */
precedence left TIMES, DIVIDE, MOD; 	/* LEVEL 12 */
precedence right NOT, BITWISE_NOT;		/* LEVEL 14 + UNARY PLUS MINUS PREINC, PREDEC */
precedence nonassoc AT, ELSE;					/* ? */
precedence left INC, DEC; 				/* LEVEL 15*/
precedence left LPAREN, RPAREN, LBRACE, RBRACE, NEW, DOT; 		/*LEVEL 16, + METHOD REFERENCE :: */





/* Productions */

CompilationUnit::= PackageDeclaration ImportDeclarations TypeDeclarations {: RESULT = "CompilationUnit-1"; :}
				|
				PackageDeclaration TypeDeclarations {: RESULT = "CompilationUnit-2"; :}
				| 
				ImportDeclarations TypeDeclarations {: RESULT = "CompilationUnit-3"; :}
				|
				TypeDeclarations	{: RESULT = "CompilationUnit-4"; :}
				;

PackageDeclaration::= Annotations PACKAGE QualifiedIdentifier SEMICOLON {: RESULT = "PackageDeclaration-1"; :}
				|
				PACKAGE QualifiedIdentifier SEMICOLON {: RESULT = "PackageDeclaration-2"; :}
				;

QualifiedIdentifier::= Identifier {: RESULT = "QualifiedIdentifier-1"; :}
 				|
				QualifiedIdentifier DOT Identifier	{: RESULT = "QualifiedIdentifier-2"; :}
				;

Annotations::= Annotation 					{: RESULT = "Annotations-1"; :}
				|	
				Annotations Annotation		{: RESULT = "Annotations-2"; :}
				;   

Annotation::= AT QualifiedIdentifier LPAREN AnnotationElement RPAREN		{: RESULT = "Annotation-1"; :}
				|
				AT QualifiedIdentifier LPAREN RPAREN						{: RESULT = "Annotation-2"; :}
				|
				AT QualifiedIdentifier										{: RESULT = "Annotation-3"; :}
				;

AnnotationElement::=
		    ElementValuePairs
		    |
		    ElementValue
		    ;

ElementValuePairs::= ElementValuePair 
			|
			ElementValuePairs COMMA ElementValuePair
			;

ElementValuePair::= Identifier BECOMES ElementValue									{: RESULT = "ElementValuePair-1"; :}
			;
    
ElementValue::=  Annotation
			|
		    Expression1 
		    |
		    ElementValueArrayInitializer
		    ;


ElementValueArrayInitializer::= LBRACE ElementValues COMMA RBRACE
			|
			LBRACE ElementValues RBRACE
			|
			LBRACE COMMA RBRACE
			|
			LBRACE RBRACE
			;


ElementValues ::= ElementValue 
			|
			ElementValues COMMA	ElementValue
			;
				
				
				
				
				
				
ImportDeclarations ::= ImportDeclaration				{: RESULT = "ImportDeclarations-1"; :}
				|
				ImportDeclarations ImportDeclaration	{: RESULT = "ImportDeclarations-2"; :}
				;					
					
ImportDeclaration::= IMPORT STATIC QualifiedIdentifier DOT TIMES SEMICOLON			{: RESULT = "ImportDeclaration-1"; :}
				|
				IMPORT STATIC QualifiedIdentifier SEMICOLON							{: RESULT = "ImportDeclaration-2"; :}
				|
				IMPORT QualifiedIdentifier DOT TIMES SEMICOLON						{: RESULT = "ImportDeclaration-3"; :}
				|
				IMPORT QualifiedIdentifier SEMICOLON								{: RESULT = "ImportDeclaration-4"; :}
				;

TypeDeclarations::= TypeDeclaration						{: RESULT = "TypeDeclarations-1"; :}
				|
				TypeDeclarations TypeDeclaration		{: RESULT = "TypeDeclarations-2"; :}	
				;

TypeDeclaration::= Modifiers ClassOrInterfaceDeclaration	{: RESULT = "TypeDeclaration-1"; :}
				|
				ClassOrInterfaceDeclaration					{: RESULT = "TypeDeclaration-2"; :}
				;

ClassOrInterfaceDeclaration::=  
				ClassDeclaration 	{: RESULT = "ClassOrInterfaceDeclaration-1"; :}
				| 
				InterfaceDeclaration {: RESULT = "ClassOrInterfaceDeclaration-2"; :}
				;

Modifiers::= Modifier Modifiers			{: RESULT = "Modifiers-1"; :}
			|
			Modifier:i					{: RESULT = "Modifiers-2 "+i; :}
			;

Modifier::=
    Annotations:i 		{: RESULT = i; :}
    | PUBLIC:i {: RESULT = i; :}
    | PROTECTED:i {: RESULT = i; :}
    | PRIVATE:i {: RESULT = i; :}
    | STATIC:i {: RESULT = i; :}
    | ABSTRACT:i {: RESULT = i; :}
    | FINAL:i {: RESULT = i; :}
    | NATIVE:i {: RESULT = i; :}
    | SYNCHRONIZED:i {: RESULT = i; :}
    | TRANSIENT:i {: RESULT = i; :}
    | VOLATILE:i {: RESULT = i; :}
    | STRICTFP:i {: RESULT = i; :}
    ;





ClassDeclaration::= NormalClassDeclaration		{: RESULT = "ClassDeclaration-1"; :}
				|
			    EnumDeclaration					{: RESULT = "ClassDeclaration-2"; :}
			    ;


InterfaceDeclaration::= NormalInterfaceDeclaration
				|
			    AnnotationTypeDeclaration
			    ;
			    
			    
NormalClassDeclaration::= CLASS Identifier TypeParameters EXTENDS Type IMPLEMENTS TypeList ClassBody		{: RESULT = "NormalClassDeclaration-1"; :}
				|
				CLASS Identifier EXTENDS Type IMPLEMENTS TypeList ClassBody								{: RESULT = "NormalClassDeclaration-2"; :}
				|
				CLASS Identifier TypeParameters IMPLEMENTS TypeList ClassBody							{: RESULT = "NormalClassDeclaration-3"; :}
				|
				CLASS Identifier TypeParameters EXTENDS Type ClassBody									{: RESULT = "NormalClassDeclaration-4"; :}
				|
				CLASS Identifier IMPLEMENTS TypeList ClassBody											{: RESULT = "NormalClassDeclaration-5"; :}
				|
				CLASS Identifier EXTENDS Type ClassBody													{: RESULT = "NormalClassDeclaration-6"; :}
				|
				CLASS Identifier TypeParameters ClassBody												{: RESULT = "NormalClassDeclaration-7"; :}
				|
				CLASS Identifier ClassBody																{: RESULT = "NormalClassDeclaration-8"; :}
				;

EnumDeclaration::= ENUM Identifier IMPLEMENTS TypeList EnumBody
				|
				ENUM Identifier EnumBody
				;

NormalInterfaceDeclaration::=  INTERFACE Identifier TypeParameters EXTENDS TypeList InterfaceBody
				|
				INTERFACE Identifier EXTENDS TypeList InterfaceBody
				|
				INTERFACE Identifier TypeParameters InterfaceBody
				|
				INTERFACE Identifier InterfaceBody
				;





AnnotationTypeDeclaration::= AT INTERFACE Identifier AnnotationTypeBody ;
				
EmptyArrays::= EmptyArray				{: RESULT = "EmptyArrays-1"; :}
			|
			EmptyArrays EmptyArray		{: RESULT = "EmptyArrays-2"; :}
			;				

EmptyArray::= LBRACKET RBRACKET;
				
Type::=
    BasicType:i EmptyArrays			{: RESULT = "Type-1 "+i+"[]"; :}
    |
    ReferenceType:i EmptyArrays		{: RESULT = "Type-2 "+i+"[]"; :}
    |
    BasicType:i 						{: RESULT = "Type-3 "+i; :}
    |
    ReferenceType:i 					{: RESULT = "Type-4 "+i; :}
    ;

BasicType::= 
    BYTE:i 		{: RESULT = i; :}
    |
    SHORT:i 		{: RESULT = i; :}
    |
    CHAR:i 		{: RESULT = i; :}
    |
    INT:i 		{: RESULT = i; :}
    |
    LONG:i 		{: RESULT = i; :}
    |
    FLOAT:i 		{: RESULT = i; :}
    |
    DOUBLE:i 		{: RESULT = i; :}
    |
    BOOLEAN:i 		{: RESULT = i; :}
    ;

ReferenceType::=
/*  FIXME
			ReferenceType DOT ChainedIdentifier TypeArguments		{: RESULT = "ReferenceType-1"; :}			
			|
			ReferenceType DOT ChainedIdentifier							{: RESULT = "ReferenceType-2"; :}
			|
	*/		
			ChainedIdentifier TypeArguments 								{: RESULT = "ReferenceType-3"; :}			
			|		
			ChainedIdentifier												{: RESULT = "ReferenceType-4"; :}
			
			;


TypeArguments ::= LT TypeArgumentList GT						{: RESULT = "TypeArguments-1"; :}
			;

TypeArgumentList ::= TypeArgument							{: RESULT = "TypeArgumentList-1"; :}
			|
			TypeArgumentList COMMA TypeArgument				{: RESULT = "TypeArgumentList-2"; :}
			;


TypeArgument::=  QUESTION EXTENDS ReferenceType				{: RESULT = "TypeArgument-1"; :}
			|
			ReferenceType									{: RESULT = "TypeArgument-2"; :}	
			;


NonWildcardTypeArguments::= GT TypeList LT				{: RESULT = "NonWildcardTypeArguments-1"; :}
			;

TypeList::=  ReferenceType				{: RESULT = "TypeList-1"; :}
			|
			COMMA TypeList				{: RESULT = "TypeList2-1"; :}
			;

TypeArgumentsOrDiamond::=
    LT GT 
    |
    TypeArguments
    ;

NonWildcardTypeArgumentsOrDiamond::=
    LT GT
    |
    NonWildcardTypeArguments
    ;


TypeParameters::= LT TypeParameterList GT    			{: RESULT = "TypeParameters-1"; :}
		;

TypeParameterList::= TypeParameter						{: RESULT = "TypeParameterList-1"; :}
			|
			TypeParameterList COMMA TypeParameter		{: RESULT = "TypeParameterList-2"; :}	
			;

TypeParameter::=			
    Identifier EXTENDS Bound		{: RESULT = "TypeParameter-1"; :}
    |
    Identifier						{: RESULT = "TypeParameter-2"; :}
    ;

Bound::=  
    ReferenceType			{: RESULT = "Bound-1"; :}
    | 
	AND Bound				{: RESULT = "Bound-2"; :}	
	;







EnumBody::=
    LBRACE EnumConstants COMMA EnumBodyDeclarations RBRACE
    |
    LBRACE COMMA EnumBodyDeclarations RBRACE
    |
    LBRACE EnumConstants EnumBodyDeclarations RBRACE
    |
    LBRACE EnumConstants COMMA RBRACE
    |
    LBRACE EnumBodyDeclarations RBRACE
    |
    LBRACE EnumConstants RBRACE
    |
    LBRACE COMMA RBRACE
    |
    LBRACE RBRACE
    ;

EnumConstants::=
    EnumConstant
    |
    EnumConstants COMMA EnumConstant
    ;

EnumConstant::=
    Annotations Identifier Arguments ClassBody
    |
    Annotations Identifier ClassBody
    |
    Annotations Identifier Arguments
    |
    Annotations Identifier 
    |
    Identifier Arguments ClassBody
    |
    Identifier ClassBody
    |
    Identifier Arguments
    |
    Identifier
    ;


EnumBodyDeclarations::=
    SEMICOLON
    |
	SEMICOLON ClassBody
    ;



AnnotationTypeBody::=
    LBRACE AnnotationTypeElementDeclarations RBRACE
    |
    LBRACE RBRACE
    ;

AnnotationTypeElementDeclarations::=
    AnnotationTypeElementDeclaration
    |
    AnnotationTypeElementDeclarations AnnotationTypeElementDeclaration
    ;

AnnotationTypeElementDeclaration::=
    Modifiers AnnotationTypeElementRest  /* mudei aqui em relação ao original modifier */
    |
    AnnotationTypeElementRest
    ;

AnnotationTypeElementRest::=
    Type Identifier AnnotationMethodOrConstantRest SEMICOLON
    
    /* FIXME
    |
    ClassDeclaration
    |
    InterfaceDeclaration
    |
    EnumDeclaration  
    |
    AnnotationTypeDeclaration    
    */
    ;

AnnotationMethodOrConstantRest::=
    AnnotationMethodRest
    |
    ConstantDeclaratorRest  /* era ConstantDeclaratorsRest */
    ;

AnnotationMethodRest::=
    LPAREN RPAREN LBRACKET RBRACKET DEFAULT ElementValue		{: RESULT = "AnnotationMethodRest-1"; :}
    |
    LPAREN RPAREN DEFAULT ElementValue		{: RESULT = "AnnotationMethodRest-2"; :}
    |
    LPAREN RPAREN LBRACKET RBRACKET		{: RESULT = "AnnotationMethodRest-3"; :}
    |
    LPAREN RPAREN 		{: RESULT = "AnnotationMethodRest-4"; :}
    ;
    
ConstantDeclaratorsRest::=
	ConstantDeclarator	
	|
    ConstantDeclaratorRest COMMA ConstantDeclarator
    ;

ConstantDeclaratorRest::=
    LBRACKET RBRACKET BECOMES VariableInitializer								{: RESULT = "ConstantDeclaratorRest-1"; :}
    |
    BECOMES VariableInitializer													{: RESULT = "ConstantDeclaratorRest-2"; :}
    ;

ConstantDeclarator::= Identifier ConstantDeclaratorRest							{: RESULT = "ConstantDeclarator-1"; :}
		;


VariableInitializer::=
    ArrayInitializer			{: RESULT = "VariableInitializer-1"; :}
    |
    Expression					{: RESULT = "VariableInitializer-2"; :}
    ;

VariableInitializerList::= VariableInitializer			{: RESULT = "VariableInitializerList-1"; :}
	|
	VariableInitializerList COMMA VariableInitializer			{: RESULT = "VariableInitializerList-2"; :}
	;


ArrayInitializer::=
    LBRACE VariableInitializerList COMMA RBRACE
    |
    LBRACE VariableInitializerList RBRACE
	;

Expression::= Expression1 AssignmentOperator Expression1 {: RESULT = "Expression-1"; :}
		|		
		Expression1		{: RESULT = "Expression-2"; :}	
		;
		
Expression1::=
    Expression2 Expression1Rest  	{: RESULT = "Expression1-1"; :}
    |
    Expression2		{: RESULT = "Expression1-2"; :}
    ;		

AssignmentOperator::= 
    BECOMES:i {: RESULT = i; :}
    | 
    PLUS_EQUALS:i {: RESULT = i; :}
    |
    MINUS_EQUALS:i {: RESULT = i; :}
    |
    TIMES_EQUALS:i {: RESULT = i; :}
    |
    DIV_EQUALS:i {: RESULT = i; :}
    |
    AND_EQUALS:i {: RESULT = i; :}
    |
    OR_EQUALS:i {: RESULT = i; :}
    |
    XOR_EQUALS:i {: RESULT = i; :}
    |
    MOD_EQUALS:i {: RESULT = i; :}
    |
	SHIFT_LEFT_EQUALS:i {: RESULT = i; :}
	|
	SHIFT_RIGHT_EQUALS:i {: RESULT = i; :}
	|
	SHIFT_RIGHT_ARITHM_EQUALS:i {: RESULT = i; :}
	;
	
	


Expression1Rest::= QUESTION Expression COLON Expression1 {: RESULT = "Expression1Rest-1"; :}
	;	

Expression2::= Expression3 Expression2Rest {: RESULT = "Expression2-1"; :}
	;

Expression2Rest::= /* empty */	{: RESULT = "Expression2Rest-1 (empty)"; :}
	|
    Expression3List	{: RESULT = "Expression2Rest-2"; :}
    |
    INSTANCEOF Type	{: RESULT = "Expression2Rest-3"; :}	
    ;
    
Expression3List::= InfixOp Expression3 	{: RESULT = "Expression3List-1"; :}
	|
	Expression3List InfixOp Expression3	{: RESULT = "Expression3List-2"; :}
	;
    
InfixOp::=
	DOUBLE_OR:i 		{: RESULT = i; :}
	|
	DOUBLE_AND:i 		{: RESULT = i; :}
	|
	AND:i 		{: RESULT = i; :}
	|
	OR:i 		{: RESULT = i; :}
	|
	XOR:i 		{: RESULT = i; :}
	|
	EQUALS:i 		{: RESULT = i; :}
	|
	NOT_EQUALS:i 		{: RESULT = i; :}
	|
	LT:i 		{: RESULT = i; :}
	|
	GT    :i 		{: RESULT = i; :}
	|
	GE:i 		{: RESULT = i; :}
	|
	LE:i 		{: RESULT = i; :}
	|
	SHIFT_LEFT:i 		{: RESULT = i; :}
	|
	SHIFT_RIGHT:i 		{: RESULT = i; :}
	|
	SHIFT_RIGHT_ARITHM:i 		{: RESULT = i; :}
	|
	PLUS:i 		{: RESULT = i; :}
	|
	MINUS:i 		{: RESULT = i; :}
	|
	TIMES:i 		{: RESULT = i; :}
	|
	DIVIDE:i 		{: RESULT = i; :}
	|
	MOD:i 		{: RESULT = i; :}
	;


Expression3::=
	/* FIXME
    PrefixOp Expression3	{: RESULT = "Expression3-1"; :}
    |
    */
    LPAREN Expression RPAREN Expression3	{: RESULT = "Expression3-2"; :}
    |
    LPAREN Type RPAREN Expression3	{: RESULT = "Expression3-3"; :}
    |
    Primary Selector PostfixOp	{: RESULT = "Expression3-4"; :}
    |
    Primary Selector	{: RESULT = "Expression3-5"; :}
    |
	Primary PostfixOp	{: RESULT = "Expression3-6"; :}
	|
	Primary				{: RESULT = "Expression3-7"; :}
	;

			
Primary::= 				
    Literal				{: RESULT = "Primary-1"; :}
    |
    ParExpression		{: RESULT = "Primary-2"; :}
    |
    THIS				{: RESULT = "Primary-3"; :}
    |
    THIS Arguments		{: RESULT = "Primary-4"; :}
    |
    SUPER SuperSuffix	{: RESULT = "Primary-5"; :}	
    |   
    NEW Creator			{: RESULT = "Primary-6"; :}
    |    
    NonWildcardTypeArguments LPAREN ExplicitGenericInvocationSuffix RPAREN		{: RESULT = "Primary-7"; :}
    |
    NonWildcardTypeArguments LPAREN THIS Arguments RPAREN		{: RESULT = "Primary-8"; :}
    |
    ChainedIdentifier IdentifierSuffix		{: RESULT = "Primary-8"; :}
	|   
	ChainedIdentifier						{: RESULT = "Primary-10"; :}
	|   	
	BasicType EmptyArrays DOT CLASS			{: RESULT = "Primary-11"; :}
    |
    BasicType DOT CLASS						{: RESULT = "Primary-12"; :}
    |
    VOID DOT CLASS							{: RESULT = "Primary-13"; :}	
    ;


ChainedIdentifier::= Identifier						{: RESULT = "ChainedIdentifier-1"; :}
			|
			ChainedIdentifier DOT Identifier		{: RESULT = "ChainedIdentifier-2"; :}
			;


PrefixOp::= 
		PostfixOp:i 		{: RESULT = i; :}
		|
		NOT:i 		{: RESULT = i; :}
		|
		BITWISE_NOT:i 		{: RESULT = i; :}
		|
		PLUS:i 		{: RESULT = i; :}
		|
		MINUS:i 		{: RESULT = i; :}
		;
    

PostfixOp::=
			INC:i 		{: RESULT = i; :}
			|
			DEC:i 		{: RESULT = i; :}
			;
			
	
IdentifierSuffix::=  Arguments {: RESULT = "IdentifierSuffix-1"; :}
	|
	DOT CLASS	{: RESULT = "IdentifierSuffix-2"; :}
	|
	DOT ExplicitGenericInvocation		{: RESULT = "IdentifierSuffix-3"; :}
	|
	DOT THIS					{: RESULT = "IdentifierSuffix-4"; :}
	|
	DOT SUPER Arguments			{: RESULT = "IdentifierSuffix-5"; :}	
	|
	DOT NEW NonWildcardTypeArguments InnerCreator		{: RESULT = "IdentifierSuffix-6"; :}
	|
	DOT NEW InnerCreator	{: RESULT = "IdentifierSuffix-7"; :}
	;
	/* FIXME
	[ ({[]} . class | Expression) ]
     


	*/
	
Literal::=
    IntegerLiteral:i 		{: RESULT = "Literal- "+i; :}
    |
    FloatingPointLiteral:i 		{: RESULT = "Literal- "+i; :}
    |
    CharacterLiteral :i 		{: RESULT = "Literal- "+i; :}
    |
    StringLiteral :i 		{: RESULT = "Literal- "+i; :}
    |
    BooleanLiteral:i 		{: RESULT = "Literal- "+i; :}
    |
    NullLiteral:i 		{: RESULT = "Literal- "+i; :}
    ;

IntegerLiteral::= INTEGER_LITERAL;

CharacterLiteral::= CHARACTER_LITERAL;

StringLiteral::= STRING_LITERAL;

BooleanLiteral::= TRUE | FALSE;

NullLiteral::= NULL;

FloatingPointLiteral ::= FLOATING_POINT_LITERAL;


ParExpression::= LPAREN Expression RPAREN			{: RESULT = "ParExpression-1"; :}	
	;

ExpressionList::= Expression						{: RESULT = "ExpressionList-1"; :}
		|
		ExpressionList COMMA Expression				{: RESULT = "ExpressionList-2"; :}
		;
		
Arguments::=  LPAREN ExpressionList RPAREN			{: RESULT = "Arguments-1"; :}
		;


Selector::=
    DOT Identifier								{: RESULT = "Selector-1"; :}
    |
    DOT Identifier Arguments					{: RESULT = "Selector-2"; :}
    |
    DOT ExplicitGenericInvocation				{: RESULT = "Selector-3"; :}
    |
    DOT THIS									{: RESULT = "Selector-4"; :}
    |
    DOT SUPER SuperSuffix						{: RESULT = "Selector-5"; :}
    |
    DOT NEW NonWildcardTypeArguments InnerCreator					{: RESULT = "Selector-6"; :}
    |
    DOT NEW InnerCreator						{: RESULT = "Selector-7"; :}
    |
    Expression									{: RESULT = "Selector-8"; :}
	;

SuperSuffix::=
    Arguments 
    |
    DOT Identifier Arguments
    |
    DOT Identifier
    ;
    

ExplicitGenericInvocationSuffix::=
    SUPER SuperSuffix
    |
    Identifier Arguments			
    ;
		

		
			
ClassBody::= LBRACE ClassBodyDeclarationList RBRACE 					{: RESULT = "ClassBody-1"; :}
		;


ClassBodyDeclarationList::= /* empty */									{: RESULT = "ClassBodyDeclarationList-1 (empty)"; :}
			|
			ClassBodyDeclarationList ClassBodyDeclaration				{: RESULT = "ClassBodyDeclarationList-2"; :}
			;
			
ClassBodyDeclaration::=     SEMICOLON						{: RESULT = "ClassBodyDeclaration-1"; :}
	|
    Modifiers MemberDecl					{: RESULT = "ClassBodyDeclaration-2"; :}
    |
    MemberDecl								{: RESULT = "ClassBodyDeclaration-3"; :}
    |
    STATIC Block							{: RESULT = "ClassBodyDeclaration-4"; :}
    |
    Block									{: RESULT = "ClassBodyDeclaration-5"; :}
    ;


MemberDecl::=
    MethodOrFieldDecl							{: RESULT = "MemberDecl-1"; :}		
    |
    VOID Identifier VoidMethodDeclaratorRest						{: RESULT = "MemberDecl-2"; :}
    |
    Identifier ConstructorDeclaratorRest						{: RESULT = "MemberDecl-3"; :}
    |
    GenericMethodOrConstructorDecl						{: RESULT = "MemberDecl-4"; :}
    |
    ClassDeclaration						{: RESULT = "MemberDecl-5"; :}
    |
    InterfaceDeclaration						{: RESULT = "MemberDecl-6"; :}
    ;



MethodOrFieldDecl::= Type Identifier MethodOrFieldRest 					{: RESULT = "MethodOrFieldDecl-1"; :}
	;

MethodOrFieldRest::=  
    FieldDeclaratorsRest SEMICOLON							{: RESULT = "MethodOrFieldRest-1"; :}
    |
    MethodDeclaratorRest						{: RESULT = "MethodOrFieldRest-2"; :}
    ;

FieldDeclaratorsRest::=  
    VariableDeclaratorRest
    |
    FieldDeclaratorsRest COMMA VariableDeclarator
    ;

VariableDeclaratorRest::=	/* empty */			{: RESULT = "VariableDeclaratorRest-1 (empty)"; :}
	|
	EmptyArrays BECOMES VariableInitializer		{: RESULT = "VariableDeclaratorRest-2"; :}
	|
	EmptyArrays						{: RESULT = "VariableDeclaratorRest-3"; :}
	|
	BECOMES VariableInitializer		{: RESULT = "VariableDeclaratorRest-4"; :}
	;


ArrayInitializer::=
	/* FIXME */
    LBRACKET VariableInitializerList RBRACKET
    |
    LBRACKET RBRACKET
    ;
	

OptionalThrowsQualifiedIdentifierList::= /* empty */{: RESULT = "OptionalThrowsQualifiedIdentifierList-1 (empty)"; :}
	|
	THROWS QualifiedIdentifierList {: RESULT = "OptionalThrowsQualifiedIdentifierList-2"; :}
	;

QualifiedIdentifierList::=
    QualifiedIdentifier 	{: RESULT = "QualifiedIdentifierList-1"; :}
    |
    QualifiedIdentifierList COMMA QualifiedIdentifier	{: RESULT = "QualifiedIdentifierList-2"; :}
	;


MethodDeclaratorRest::=
    FormalParameters EmptyArrays OptionalThrowsQualifiedIdentifierList Block	{: RESULT = "MethodDeclaratorRest-1"; :}
    |
    FormalParameters EmptyArrays OptionalThrowsQualifiedIdentifierList SEMICOLON	{: RESULT = "MethodDeclaratorRest-2"; :}
	|
    FormalParameters OptionalThrowsQualifiedIdentifierList Block	{: RESULT = "MethodDeclaratorRest-3"; :}
    |
    FormalParameters OptionalThrowsQualifiedIdentifierList SEMICOLON	{: RESULT = "MethodDeclaratorRest-4"; :}
    ;

VoidMethodDeclaratorRest::=
    FormalParameters OptionalThrowsQualifiedIdentifierList Block	{: RESULT = "VoidMethodDeclaratorRest-1"; :}
    |
    FormalParameters OptionalThrowsQualifiedIdentifierList SEMICOLON	{: RESULT = "VoidMethodDeclaratorRest-2"; :}
    ;


ConstructorDeclaratorRest::=
    FormalParameters OptionalThrowsQualifiedIdentifierList Block ;

GenericMethodOrConstructorDecl::=
    TypeParameters GenericMethodOrConstructorRest;


GenericMethodOrConstructorRest::= VOID Identifier MethodDeclaratorRest
	| 
	Type Identifier MethodDeclaratorRest
	|
    Identifier ConstructorDeclaratorRest
    ;


FormalParameters::= LPAREN RPAREN				{: RESULT = "FormalParameters-1"; :}
	| 
    LPAREN FormalParameterDecls RPAREN		{: RESULT = "FormalParameters-2"; :}
    ;

FormalParameterDecls::= 
    VariableModifierList Type FormalParameterDeclsRest	{: RESULT = "FormalParameterDecls-1"; :}
    |
    Type FormalParameterDeclsRest		{: RESULT = "FormalParameterDecls-2"; :}
    ;

VariableModifierList ::=
			VariableModifierList VariableModifier	{: RESULT = "VariableModifierList-1"; :} 
			|
			VariableModifier 		{: RESULT = "VariableModifierList-2"; :}
			; 	
	

VariableModifier::=
    FINAL:i {: RESULT = i; :}
    |
    Annotation:i {: RESULT = i; :}
    ;

FormalParameterDeclsRest::= 
    VariableDeclaratorId COMMA FormalParameterDecls
    |
    VariableDeclaratorId
    |
    ELLIPSIS VariableDeclaratorId
    ;



VariableDeclaratorId::= Identifier 
		|
		Identifier EmptyArrays
		;



Block::= LBRACE RBRACE
	|
	LBRACE BlockStatements RBRACE;
	
	
BlockStatements::= BlockStatement
	|
	BlockStatements BlockStatement
	;	

BlockStatement::=
    LocalVariableDeclarationStatement
    |
    Statement
/*    
    |
    ClassOrInterfaceDeclaration
    |
    Identifier COLON Statement
   */ 
    ;

LocalVariableDeclarationStatement::= VariableModifierList Type VariableDeclarators SEMICOLON {: RESULT = "LocalVariableDeclarationStatement-1"; :}
	|
	Type VariableDeclarators SEMICOLON {: RESULT = "LocalVariableDeclarationStatement-2"; :}
	; 

Statement::=
    RETURN Expression SEMICOLON	 {: RESULT = "Statement-1"; :}
    |
    RETURN SEMICOLON    	 {: RESULT = "Statement-2"; :}
    |
    Block	 {: RESULT = "Statement-3"; :}
    |    
    SEMICOLON	 {: RESULT = "Statement-4"; :}
    |
    IF ParExpression Statement ELSE Statement	 {: RESULT = "Statement-5"; :}
    |
    IF ParExpression Statement	 {: RESULT = "Statement-6"; :}
    |
    TRY Block Finally	 {: RESULT = "Statement-7"; :}
    |
    TRY Block Catches Finally	 {: RESULT = "Statement-8"; :}
    |
    TRY Block Catches	 {: RESULT = "Statement-9"; :}
    |
    THROW Expression SEMICOLON	 {: RESULT = "Statement-10"; :}
    |
    SYNCHRONIZED ParExpression Block	 {: RESULT = "Statement-11"; :}
 	|
 	WHILE ParExpression Statement	 {: RESULT = "Statement-12"; :}
 	| 
    DO Statement WHILE ParExpression SEMICOLON	 {: RESULT = "Statement-13"; :}
    |
    BREAK Identifier SEMICOLON	 {: RESULT = "Statement-14"; :}
    |
    BREAK SEMICOLON	 {: RESULT = "Statement-15"; :}
    |
    CONTINUE Identifier SEMICOLON	 {: RESULT = "Statement-16"; :}
    |
    CONTINUE SEMICOLON         	 {: RESULT = "Statement-17"; :}
    |     
    ASSERT Expression COLON Expression SEMICOLON	 {: RESULT = "Statement-18"; :}
    |
    ASSERT Expression SEMICOLON  	 {: RESULT = "Statement-19"; :}
    |
    TRY ResourceSpecification Block Catches Finally	 {: RESULT = "Statement-20"; :}
    |
    TRY ResourceSpecification Block Catches	 {: RESULT = "Statement-21"; :}
    |
    TRY ResourceSpecification Block Finally	 {: RESULT = "Statement-22"; :}
    |        
    TRY ResourceSpecification Block	 {: RESULT = "Statement-23"; :}
    
    
    
        
    /*
    
    |
    SWITCH ParExpression SwitchBlockStatementGroups
    |
    FOR LPAREN ForControl RPAREN Statement
    |
    Identifier COLON Statement





    
    |
    StatementExpression SEMICOLON
    
    





    */
    
    ;

StatementExpression::=			 {: RESULT = "StatementExpression-1"; :}
    Expression
    ;


SwitchBlockStatementGroups::= SwitchBlockStatementGroup
	|
	SwitchBlockStatementGroups SwitchBlockStatementGroup
	;
	
SwitchBlockStatementGroup::= 
    SwitchLabels BlockStatements
    ;

SwitchLabels::=
    SwitchLabels SwitchLabel
    |
    SwitchLabel
    ;

SwitchLabel::=
    CASE Expression COLON
    |
    CASE EnumConstantName COLON
    |
    DEFAULT COLON
    ;

EnumConstantName::=
    Identifier
    ;

	 
ForControl::=
    ForVarControl
    |
    ForInit SEMICOLON Expression SEMICOLON ForUpdate
    |
    ForInit SEMICOLON Expression SEMICOLON
    | 
    ForInit SEMICOLON SEMICOLON ForUpdate
    |
    ForInit SEMICOLON SEMICOLON
    ;

ForVarControl::=
    VariableModifierList Type VariableDeclaratorId  ForVarControlRest
    |
    Type VariableDeclaratorId  ForVarControlRest
    ;

ForVarControlRest::=
    ForVariableDeclaratorsRest SEMICOLON Expression SEMICOLON ForUpdate
    |
    ForVariableDeclaratorsRest SEMICOLON Expression SEMICOLON
    |
    ForVariableDeclaratorsRest SEMICOLON SEMICOLON ForUpdate
    |
    ForVariableDeclaratorsRest SEMICOLON SEMICOLON
    | 
    COLON Expression
    ;

ForVariableDeclaratorsRest::=  OptionalVariableInitializer VariableDeclaratorList
	;

OptionalVariableInitializer::= /* empty */		{: RESULT = "OptionalVariableInitializer-1"; :}
	|
	BECOMES VariableInitializer					{: RESULT = "OptionalVariableInitializer-2"; :}
	;
	

VariableDeclaratorList ::= COMMA VariableDeclarator 
	| 
	VariableDeclaratorList COMMA VariableDeclarator
	;

ForInit::=
 	ForInit COMMA StatementExpression     
 	|
 	StatementExpression
 	;
 
ForUpdate::=
 	ForUpdate COMMA StatementExpression     
 	|
 	StatementExpression
 	;
    
    
ResourceSpecification::=
    LPAREN Resources SEMICOLON RPAREN 		{: RESULT = "ResourceSpecification-1"; :}
    |
    LPAREN Resources RPAREN 		{: RESULT = "ResourceSpecification-2"; :}
    ;

Resources::=
    Resource
    |
    Resources SEMICOLON Resource
    ;

Resource::=
    VariableModifierList ReferenceType VariableDeclaratorId BECOMES Expression {: RESULT = "Resource-1"; :}
    |
    ReferenceType VariableDeclaratorId BECOMES Expression {: RESULT = "Resource-2"; :}
    ; 



VariableDeclarators::=
    VariableDeclarators COMMA VariableDeclarator
    |
    VariableDeclarator
    ;

VariableDeclarator::=
    Identifier VariableDeclaratorRest
    ;



Catches::=
    CatchClause
    |
    Catches CatchClause
    ;

CatchClause::=  
    CATCH LPAREN VariableModifierList CatchType Identifier RPAREN Block  		{: RESULT = "CatchClause-1"; :}
    |
    CATCH LPAREN CatchType Identifier RPAREN Block  		{: RESULT = "CatchClause-2"; :}
    ;

CatchType::=
    CatchType OR QualifiedIdentifier
    |
    QualifiedIdentifier
    ;

Finally::=
    FINALLY Block
    ;












InterfaceBody::= LBRACE RBRACE
	|
	LBRACE InterfaceBodyDeclarationList RBRACE
	;
	
InterfaceBodyDeclarationList::= InterfaceBodyDeclarationList InterfaceBodyDeclaration
	|
	InterfaceBodyDeclaration
	;	
	
	
InterfaceBodyDeclaration ::=  
	SEMICOLON
	|
    Modifiers InterfaceMemberDecl
    |
    InterfaceMemberDecl
    ;


InterfaceMemberDecl::=
    InterfaceMethodOrFieldDecl
    |
    VOID Identifier VoidInterfaceMethodDeclaratorRest
    |
    InterfaceGenericMethodDecl
    |
    ClassDeclaration
    |
    InterfaceDeclaration
    ;

InterfaceMethodOrFieldDecl::=
    Type Identifier InterfaceMethodOrFieldRest
    ;

InterfaceMethodOrFieldRest::=
    ConstantDeclaratorsRest SEMICOLON
    |
    InterfaceMethodDeclaratorRest
    ;



InterfaceMethodDeclaratorRest::=	
    FormalParameters EmptyArrays THROWS QualifiedIdentifierList SEMICOLON
    |
    FormalParameters EmptyArrays SEMICOLON
    ; 
	
VoidInterfaceMethodDeclaratorRest::=
	FormalParameters THROWS QualifiedIdentifierList SEMICOLON
	|
	FormalParameters
	;


InterfaceGenericMethodDecl::=
	TypeParameters Type Identifier InterfaceMethodDeclaratorRest
	|
	TypeParameters VOID Identifier InterfaceMethodDeclaratorRest
	;

Creator::=
    NonWildcardTypeArguments CreatedName ClassCreatorRest
    |
    CreatedName ClassCreatorRest
    |
    CreatedName ArrayCreatorRest
	;
	
CreatedName::=   
    CreatedName DOT Identifier TypeArgumentsOrDiamond
    |
    CreatedName DOT Identifier
    |
    Identifier TypeArgumentsOrDiamond
    |
    Identifier
    ;

ClassCreatorRest::=
    Arguments ClassBody
    |
    Arguments
	;

/* FIXME */
ArrayCreatorRest::=      
     LBRACE RBRACE EmptyArrays ArrayInitializer  
    |  
     LBRACE Expression RBRACE EmptyArrays 
    ;
    
    
InnerCreator::=  
    Identifier NonWildcardTypeArgumentsOrDiamond ClassCreatorRest
    |
    Identifier ClassCreatorRest
    ;
    


Identifier::= IDENTIFIER:i {: RESULT="Identifier "+i; :} 
	;
